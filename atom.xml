<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Akring&#39;s Blog</title>
  
  <subtitle>Everything is permitted</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.akringblog.com/"/>
  <updated>2019-01-17T05:29:49.826Z</updated>
  <id>https://www.akringblog.com/</id>
  
  <author>
    <name>Akring</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2019/01/17/Flutter%20Card%20%E4%B8%AD%E5%9B%BE%E7%89%87%E5%9C%86%E8%A7%92%E6%98%BE%E7%A4%BA/"/>
    <id>https://www.akringblog.com/2019/01/17/Flutter Card 中图片圆角显示/</id>
    <published>2019-01-17T05:27:42.547Z</published>
    <updated>2019-01-17T05:29:49.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter-Card-中图片圆角显示"><a href="#Flutter-Card-中图片圆角显示" class="headerlink" title="Flutter Card 中图片圆角显示"></a>Flutter Card 中图片圆角显示</h1><p>需在 <code>Card</code> 组件中显式申明：<code>clipBehavior: Clip.antiAlias,</code>，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class _CardItemState extends State&lt;CardItem&gt; &#123;</span><br><span class="line">  void _clicked() &#123;&#125;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      padding: EdgeInsets.all(10),</span><br><span class="line">      // height: 200,</span><br><span class="line">      child: new Card(</span><br><span class="line">        clipBehavior: Clip.antiAlias,</span><br><span class="line">        child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Image.asset(</span><br><span class="line">              &quot;images/userBgImag.png&quot;,</span><br><span class="line">              // fit: BoxFit.cover,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flutter-Card-中图片圆角显示&quot;&gt;&lt;a href=&quot;#Flutter-Card-中图片圆角显示&quot; class=&quot;headerlink&quot; title=&quot;Flutter Card 中图片圆角显示&quot;&gt;&lt;/a&gt;Flutter Card 中图片圆角显示&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.akringblog.com/2019/01/17/hello-world/"/>
    <id>https://www.akringblog.com/2019/01/17/hello-world/</id>
    <published>2019-01-17T02:58:09.950Z</published>
    <updated>2019-01-17T02:58:09.951Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2018/12/23/iOS%20Moya%20%E5%AE%9E%E7%8E%B0%20OAuth%202.0%20%E8%AF%B7%E6%B1%82/"/>
    <id>https://www.akringblog.com/2018/12/23/iOS Moya 实现 OAuth 2.0 请求/</id>
    <published>2018-12-23T15:54:22.945Z</published>
    <updated>2019-01-20T10:57:47.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-Moya-实现-OAuth-2-0-请求"><a href="#iOS-Moya-实现-OAuth-2-0-请求" class="headerlink" title="iOS Moya 实现 OAuth 2.0 请求"></a>iOS Moya 实现 OAuth 2.0 请求</h1><h2 id="0-起源"><a href="#0-起源" class="headerlink" title="0. 起源"></a>0. 起源</h2><p>开放授权（OAuth）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。<br>而作为第三方软件，为用户提供 OAuth 登录是更好的选择，可以有效打消用户对于个人账户密码泄露的顾虑，同时也能有效避免用户反复登录，进而增加用户的舒适度，提高用户粘性。</p><h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>项目使用 MVVM 架构，引入了 Rx 全家桶，网络请求框架使用了 <a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>，以及处理 Oauth 相关的库 <a href="https://github.com/p2/OAuth2" target="_blank" rel="noopener">OAuth2</a>。</p><h2 id="2-OAuth2-部分"><a href="#2-OAuth2-部分" class="headerlink" title="2. OAuth2 部分"></a>2. OAuth2 部分</h2><p>参阅 OAuth2 库的<a href="https://github.com/p2/OAuth2" target="_blank" rel="noopener">README</a>，完成 OAuth 的信息配置：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oauth2 = <span class="type">OAuth2CodeGrant</span>(settings: [</span><br><span class="line">    <span class="string">"client_id"</span>: <span class="string">"my_swift_app"</span>,</span><br><span class="line">    <span class="string">"client_secret"</span>: <span class="string">"C7447242"</span>,</span><br><span class="line">    <span class="string">"authorize_uri"</span>: <span class="string">"https://github.com/login/oauth/authorize"</span>,</span><br><span class="line">    <span class="string">"token_uri"</span>: <span class="string">"https://github.com/login/oauth/access_token"</span>,   <span class="comment">// code grant only</span></span><br><span class="line">    <span class="string">"redirect_uris"</span>: [<span class="string">"myapp://oauth/callback"</span>],   <span class="comment">// register your own "myapp" scheme in Info.plist</span></span><br><span class="line">    <span class="string">"scope"</span>: <span class="string">"user repo:status"</span>,</span><br><span class="line">    <span class="string">"secret_in_body"</span>: <span class="literal">true</span>,    <span class="comment">// Github needs this</span></span><br><span class="line">    <span class="string">"keychain"</span>: <span class="literal">false</span>,         <span class="comment">// if you DON'T want keychain integration</span></span><br><span class="line">] <span class="keyword">as</span> <span class="type">OAuth2JSON</span>)</span><br></pre></td></tr></table></figure></p><p>同时因为 Moya 的底层网络请求实现是基于 Alamofire，因此我们可以参照 OAuth2 提供的说明文档 <a href="https://github.com/p2/OAuth2/wiki/Alamofire-4" target="_blank" rel="noopener">Alamofire 4 · p2/OAuth2 Wiki · GitHub</a> 完成相关配置，关键代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> OAuth2</span><br><span class="line"><span class="keyword">import</span> Alamofire</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OAuth2RetryHandler</span>: <span class="title">RequestRetrier</span>, <span class="title">RequestAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> loader: <span class="type">OAuth2DataLoader</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(oauth2: <span class="type">OAuth2</span>) &#123;</span><br><span class="line">        loader = <span class="type">OAuth2DataLoader</span>(oauth2: oauth2)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Intercept 401 and do an OAuth2 authorization.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">should</span><span class="params">(<span class="number">_</span> manager: SessionManager, retry request: Request, with error: Error, completion: @escaping RequestRetryCompletion)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> response = request.task?.response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>, <span class="number">401</span> == response.statusCode, <span class="keyword">let</span> req = request.request &#123;</span><br><span class="line">            <span class="keyword">var</span> dataRequest = <span class="type">OAuth2DataRequest</span>(request: req, callback: &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;)</span><br><span class="line">            dataRequest.context = completion</span><br><span class="line">            loader.enqueue(request: dataRequest)</span><br><span class="line">            loader.attemptToAuthorize() &#123; authParams, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.loader.dequeueAndApply() &#123; req <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> comp = req.context <span class="keyword">as</span>? <span class="type">RequestRetryCompletion</span> &#123;</span><br><span class="line">                        comp(<span class="literal">nil</span> != authParams, <span class="number">0.0</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            completion(<span class="literal">false</span>, <span class="number">0.0</span>)   <span class="comment">// not a 401, not our problem</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Sign the request with the access token.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">adapt</span><span class="params">(<span class="number">_</span> urlRequest: URLRequest)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">URLRequest</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="literal">nil</span> != loader.oauth2.accessToken <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> urlRequest</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> urlRequest.signed(with: loader.oauth2)   <span class="comment">// "try" added in 3.0.2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-Moya-部分"><a href="#3-Moya-部分" class="headerlink" title="3. Moya 部分"></a>3. Moya 部分</h2><p>Moya 的 provider 在初始化时可以传入 <code>SessionManager</code> ，因此参照文档，可以先使用 OAuth2 生成一个特定的 <code>SessionManager</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getManager</span><span class="params">()</span></span> -&gt; <span class="type">SessionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> oauth2 = <span class="type">OAuth2CodeGrant</span>(settings: [</span><br><span class="line">            <span class="string">"client_id"</span>: <span class="string">"my_swift_app"</span>,</span><br><span class="line">            <span class="string">"client_secret"</span>: <span class="string">"C7447242"</span>,</span><br><span class="line">            <span class="string">"authorize_uri"</span>: <span class="string">"https://github.com/login/oauth/authorize"</span>,</span><br><span class="line">            <span class="string">"token_uri"</span>: <span class="string">"https://github.com/login/oauth/access_token"</span>,   <span class="comment">// code grant only</span></span><br><span class="line">            <span class="string">"redirect_uris"</span>: [<span class="string">"myapp://oauth/callback"</span>],   <span class="comment">// register your own "myapp" scheme in Info.plist</span></span><br><span class="line">            <span class="string">"scope"</span>: <span class="string">"user repo:status"</span>,</span><br><span class="line">            <span class="string">"secret_in_body"</span>: <span class="literal">true</span>,    <span class="comment">// Github needs this</span></span><br><span class="line">            <span class="string">"keychain"</span>: <span class="literal">false</span>,         <span class="comment">// if you DON'T want keychain integration</span></span><br><span class="line">            ] <span class="keyword">as</span> <span class="type">OAuth2JSON</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> sessionManager = <span class="type">SessionManager</span>()</span><br><span class="line">        <span class="keyword">let</span> oauthHandler = <span class="type">OAuth2Handler</span>(oauth2: oauth2)</span><br><span class="line">        sessionManager.adapter = oauthHandler</span><br><span class="line">        sessionManager.retrier = oauthHandler</span><br><span class="line">        <span class="keyword">return</span> sessionManager</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>进而生成带 OAuth 的 provider：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> provider: <span class="type">MoyaProvider</span> = &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="type">MoyaProvider</span>&lt;<span class="type">API</span>&gt;(manager: <span class="keyword">self</span>.getManager(), plugins: [<span class="type">NetworkLoggerPlugin</span>()])</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用生成的 <code>provider</code>发送请求即可，此时 Moya 可自动处理 OAuth 认证信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-Moya-实现-OAuth-2-0-请求&quot;&gt;&lt;a href=&quot;#iOS-Moya-实现-OAuth-2-0-请求&quot; class=&quot;headerlink&quot; title=&quot;iOS Moya 实现 OAuth 2.0 请求&quot;&gt;&lt;/a&gt;iOS Moya 实现 OA
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2018/12/05/Swift%20Lint%20%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.akringblog.com/2018/12/05/Swift Lint 的配置和使用/</id>
    <published>2018-12-04T16:15:14.650Z</published>
    <updated>2018-12-09T15:36:00.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-Lint-的配置和使用"><a href="#Swift-Lint-的配置和使用" class="headerlink" title="Swift Lint 的配置和使用"></a>Swift Lint 的配置和使用</h1><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>个人倾向于使用 Homebre 直接安装在 Mac 上，无需对每个项目的 Podfile 做改动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install swiftlint</span><br></pre></td></tr></table></figure><p>完成安装后，还需要在项目中添加一个 <code>Run Script</code>，使每次 Build 都会自动调用 Swift Lint 作代码扫描和校正。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">which</span> swiftlint &gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">  swiftlint</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p>以上脚本的 <code>else</code> 分支会在当前设备未安装/配置 Swift Lint 的时候在控制台输出提示  </p></blockquote><h2 id="二、Swift-Lint-配置"><a href="#二、Swift-Lint-配置" class="headerlink" title="二、Swift Lint 配置"></a>二、Swift Lint 配置</h2><p>项目中可能会使用<code>Cocoapods</code>或<code>Carthage</code>引入了第三方库，如果不对 Swift Lint 加以配置，则会导致这部分第三方库也被纳入到代码检查的范围，这是我们不期望看到的。同时，如果你正在维护一个历史久远，可能从 Swfit 2 时期就存在的项目的话，打开 Swift Lint 之后你将可能看到 <code>999+</code>个红色的编译错误。同时大量修改代码，并确保功能不出问题，这对任何人来说应该都是极大的负担，在这种情况下，我们可能会期望暂时禁用某些规则，如<code>force_cast</code>，以便在确保项目正常编译的同时，渐进式的完成 Swfit Lint 的修改工作，而这一切都必须依赖于自定义的 <code>.swiftlint.yml</code>配置文件。</p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>在项目根目录下创建一个<code>.swiftlint.yml</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .swiftlint.yml</span><br></pre></td></tr></table></figure><p>然后为其加入如下代码：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">excluded:</span> <span class="comment"># 你所希望不要检索的路径,SwiftLint会无视掉该路径下的文件</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Carthage</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Pods</span></span><br></pre></td></tr></table></figure><p>即可方便的忽略掉通过<code>Cocoapods</code>或<code>Carthage</code>引入的第三方库，如果项目中还有其他不想要做 Swift Lint 代码检查的文件或目录，也照此办理即可。</p><h3 id="禁用规则"><a href="#禁用规则" class="headerlink" title="禁用规则"></a>禁用规则</h3><p>在<code>.swiftlint.yml</code>中加入如下代码：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disabled_rules:</span> <span class="comment"># 禁用指定的规则</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">force_try</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">force_cast</span></span><br></pre></td></tr></table></figure><p>即可禁用对应的规则</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-Lint-的配置和使用&quot;&gt;&lt;a href=&quot;#Swift-Lint-的配置和使用&quot; class=&quot;headerlink&quot; title=&quot;Swift Lint 的配置和使用&quot;&gt;&lt;/a&gt;Swift Lint 的配置和使用&lt;/h1&gt;&lt;h2 id=&quot;一、安装&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/19/Flask%E6%96%87%E6%A1%A3%E8%AF%BB%E7%B0%BF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.akringblog.com/2017/04/19/Flask文档读簿（一）/</id>
    <published>2017-04-19T08:06:38.544Z</published>
    <updated>2018-12-14T06:33:51.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flask文档读簿（一）"><a href="#Flask文档读簿（一）" class="headerlink" title="Flask文档读簿（一）"></a>Flask文档读簿（一）</h1><blockquote><p>主要摘引自Flask文档的《快速入门》章节  </p></blockquote><h3 id="启用调试模式"><a href="#启用调试模式" class="headerlink" title="启用调试模式"></a>启用调试模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h3 id="多个地址Route的写法"><a href="#多个地址Route的写法" class="headerlink" title="多个地址Route的写法"></a>多个地址Route的写法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Index Page'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><h3 id="附加变量"><a href="#附加变量" class="headerlink" title="附加变量"></a>附加变量</h3><ul><li>附加原始变量：<code>&lt;variable_name&gt;</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/user/&lt;username&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_user_profile</span><span class="params">(username)</span>:</span></span><br><span class="line">    <span class="comment"># 展示用户名</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'User %s'</span> % username</span><br></pre></td></tr></table></figure><ul><li>附加转换变量：<code>&lt;converter:variable_name&gt;</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/post/&lt;int:post_id&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_post</span><span class="params">(post_id)</span>:</span></span><br><span class="line">    <span class="comment"># 展示int类型的post_id</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Post %d'</span> % post_id</span><br></pre></td></tr></table></figure><h3 id="网址的唯一性"><a href="#网址的唯一性" class="headerlink" title="网址的唯一性"></a>网址的唯一性</h3><p>根据URL地址结尾是否带有<code>/</code>，可以分为以下两种情况：</p><ul><li>结尾带有<code>/</code>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/projects/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">projects</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'The project page'</span></span><br></pre></td></tr></table></figure><p>在这种情况下，无论输入<code>xxx/projects/</code>还是<code>xxx/projects</code>，都能够正确访问到projects页面，而不用担心404错误    </p><ul><li>结尾不带<code>/</code>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/about')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">about</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'The about page"</span></span><br></pre></td></tr></table></figure><p>在这种情况下，访问<code>xxx/about</code>没有问题，而访问<code>xxx/about/</code>就会报404</p><h3 id="构建URL"><a href="#构建URL" class="headerlink" title="构建URL"></a>构建URL</h3><p>使用<code>url_for()</code>函数来构造URL：</p><p><strong>函数格式：<code>url_for(&#39;函数名&#39;, 参数)</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/profile')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span><span class="params">(username)</span>:</span> </span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> url_for(<span class="string">'profile'</span>, username=<span class="string">'John Doe'</span>)</span><br><span class="line"><span class="comment"># 输出/user/John%20Doe</span></span><br></pre></td></tr></table></figure><p>动态构建URL的好处：</p><ol><li>比硬编码更具备描述性</li><li>允许你一次性修改 URL，而不是到处去找 URL 做修改。</li><li>URL 构建会显式地处理特殊字符和 Unicode 数据的转义</li><li>如果应用不位于 URL 的根路径，url_for() 会为你妥善地处理这些。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flask文档读簿（一）&quot;&gt;&lt;a href=&quot;#Flask文档读簿（一）&quot; class=&quot;headerlink&quot; title=&quot;Flask文档读簿（一）&quot;&gt;&lt;/a&gt;Flask文档读簿（一）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;主要摘引自Flask文档的《快速入
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/16/%E8%87%AA%E5%AE%9A%E4%B9%89Mac%E6%A0%87%E9%A2%98%E6%A0%8F%E6%A0%B7%E5%BC%8F/"/>
    <id>https://www.akringblog.com/2017/04/16/自定义Mac标题栏样式/</id>
    <published>2017-04-16T08:31:18.623Z</published>
    <updated>2017-04-19T07:38:37.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义Mac标题栏样式"><a href="#自定义Mac标题栏样式" class="headerlink" title="自定义Mac标题栏样式"></a>自定义Mac标题栏样式</h1><p>与默认的Mac APP标题栏相比，类似Mac原生应用Reminder的标题栏具有更好的显示效果，标题栏和下方的Content View有效融合，整体风格能够保持一致。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://akring-blog-image.qiniudn.com/2017-04-16-083042.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>而要实现这种风格，我们只需要对当前NSWindow做如下处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.titlebarAppearsTransparent = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>对于这个属性，Apple官方文档里是这样解释的：</p><blockquote><p>When the value of this property is true, the title bar does not draw its background, which allows all content underneath it to show through. It only makes sense to set this property to true when NSFullSizeContentViewWindowMask is also set.  </p></blockquote><p>当<code>titlebarAppearsTransparent</code>设为<code>true</code>的时候，title bar将不会绘制其背景，换而言之，title bar将会变成透明的，使其完全和下面的View融为一体。</p><p>与此同时，Apple还提到，将这个属性设置为true的同时，我们还需要设置Window<br>的<code>NSFullSizeContentViewWindowMask</code>，如以下代码所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.styleMask = [.fullSizeContentView]</span><br></pre></td></tr></table></figure><p>本文涉及的完整代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>: <span class="title">NSWindow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.title = <span class="string">"Star Order"</span></span><br><span class="line">        <span class="keyword">self</span>.styleMask = [.fullSizeContentView, .titled, .miniaturizable, .resizable, .closable]</span><br><span class="line">        <span class="keyword">self</span>.titlebarAppearsTransparent = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Utils</span>.positionWindowAtCenter(sender: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自定义Mac标题栏样式&quot;&gt;&lt;a href=&quot;#自定义Mac标题栏样式&quot; class=&quot;headerlink&quot; title=&quot;自定义Mac标题栏样式&quot;&gt;&lt;/a&gt;自定义Mac标题栏样式&lt;/h1&gt;&lt;p&gt;与默认的Mac APP标题栏相比，类似Mac原生应用Reminder
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/16/Mac%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%A2%98%E6%A0%8F%E5%93%8D%E5%BA%94%E5%8F%8C%E5%87%BBZoom%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://www.akringblog.com/2017/04/16/Mac自定义标题栏响应双击Zoom的方法/</id>
    <published>2017-04-16T08:21:07.904Z</published>
    <updated>2017-04-19T07:35:46.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac自定义标题栏响应双击Zoom的方法"><a href="#Mac自定义标题栏响应双击Zoom的方法" class="headerlink" title="Mac自定义标题栏响应双击Zoom的方法"></a>Mac自定义标题栏响应双击Zoom的方法</h1><p>在之前的博文中我们实现了类似Reminder的实现：<a href="http://akringblog.com/custom-mac-title-bar/" target="_blank" rel="noopener">《自定义Mac标题栏样式》</a></p><p>然而，使用以上方法实现自定义标题栏，会带来一个额外的副作用：双击Title bar无法再实现默认Window的Zoom效果，即无法自动缩放窗口到全屏效果。</p><p>发现这个问题后我测试了Mac自带的Reminder应用，发现同样具有这个问题，由此可见这也许是一个OS X的 Bug，或是一个人所未知的“feature”。Anyway， 为了解决这个问题，我使用了一个比较非主流的方式，记录如下。</p><h1 id="一、总体思路"><a href="#一、总体思路" class="headerlink" title="一、总体思路"></a>一、总体思路</h1><p>通过查看文档和Storyboard文件，作为First Responder的Window具有一个叫做<code>performZoom</code>的方法，而通过触发这个方法，Window就会执行缩放操作。<br>如此一来，问题的解决方案可以归为：</p><ol><li>响应双击事件</li><li>判定点击区域是否在title bar内</li><li>执行<code>performZoom</code>进行缩放</li></ol><h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h3 id="1-响应双击事件"><a href="#1-响应双击事件" class="headerlink" title="1. 响应双击事件"></a>1. 响应双击事件</h3><p>通过覆写<code>mouseDown(with event: NSEvent)</code>方法，检测鼠标点击事件，实现代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">mouseDown</span><span class="params">(with event: NSEvent)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.clickCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//双击相关处理</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.mouseDown(with: event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-判定点击区域是否在title-bar内"><a href="#2-判定点击区域是否在title-bar内" class="headerlink" title="2. 判定点击区域是否在title bar内"></a>2. 判定点击区域是否在title bar内</h3><p>通过<code>event</code>检测鼠标点击的位置，并进一步通过<code>func convert(_ point: NSPoint, to view: NSView?) -&gt; NSPoint</code>方法将点击点映射到目的View上，从而检测是否点击到了所需的View上。代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> location = <span class="keyword">self</span>.view.convert(event.locationInWindow, to: statusBar)</span><br><span class="line">            <span class="keyword">if</span> (location.x &gt;= <span class="number">0</span> &amp;&amp; location.y &gt;= <span class="number">0</span>) &#123;<span class="comment">//即点击点位于statusBar内部</span></span><br><span class="line">                <span class="comment">//执行操作</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="3-执行performZoom进行缩放"><a href="#3-执行performZoom进行缩放" class="headerlink" title="3. 执行performZoom进行缩放"></a>3. 执行<code>performZoom</code>进行缩放</h3><p>执行Zoom操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.window?.performZoom(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">override func mouseDown(with event: NSEvent) &#123;</span><br><span class="line">        if (event.clickCount &gt; 1) &#123;</span><br><span class="line">            //双击相关处理</span><br><span class="line">            let location = self.view.convert(event.locationInWindow, to: statusBar)</span><br><span class="line">            if (location.x &gt;= 0 &amp;&amp; location.y &gt;= 0) &#123;//即点击点位于statusBar内部</span><br><span class="line">                self.view.window?.performZoom(nil)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        else&#123;</span><br><span class="line">            super.mouseDown(with: event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="三、相关思考"><a href="#三、相关思考" class="headerlink" title="三、相关思考"></a>三、相关思考</h3><p>其实一开始使用这样的方法我是拒绝的，因为怎么看都有一种 -钦定- 黑魔法的感觉。然而在有了比较多的Mac开发经历之后，我对此已经见怪不怪了。相比iOS， Mac开发总是需要subclass更多，hack更多。</p><p>除此之外，对知名应用Omnifocus的观察也让我觉得，这很可能是一条可行的路线，通过观察Omnifocus的行为，我发现其相应双击Zoom的响应区域更大，如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://akring-blog-image.qiniudn.com/2017-04-16-093807.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>他的整个Tool Bar 和 Title Bar都可以响应双击事件，而根据我的解决方案，只需要将双击判定区域扩大到整个Tool Bar，即可轻松实现这个效果。再对比官方Reminders完全无法Zoom的行为，依然觉得Apple还得多加努力啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac自定义标题栏响应双击Zoom的方法&quot;&gt;&lt;a href=&quot;#Mac自定义标题栏响应双击Zoom的方法&quot; class=&quot;headerlink&quot; title=&quot;Mac自定义标题栏响应双击Zoom的方法&quot;&gt;&lt;/a&gt;Mac自定义标题栏响应双击Zoom的方法&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/Apple%20Watchkit%EF%BC%88Glance%E9%83%A8%E5%88%86%EF%BC%89/"/>
    <id>https://www.akringblog.com/2017/04/07/Apple Watchkit（Glance部分）/</id>
    <published>2017-04-07T10:03:37.883Z</published>
    <updated>2017-04-19T07:47:48.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apple-Watchkit（Glance部分）"><a href="#Apple-Watchkit（Glance部分）" class="headerlink" title="Apple Watchkit（Glance部分）"></a>Apple Watchkit（Glance部分）</h1><p>Glance在英语中的字面意思是（一瞥;一滑;闪光），由此可见在WatchKit的UI体系中，Glance担负的任务是为用户提供实时快捷，简单明了的信息获取窗口。对Watch app来说，Glance是可选项，开发者可以选择性的对其进行实现。</p><a id="more"></a><h3 id="一、特性"><a href="#一、特性" class="headerlink" title="一、特性"></a>一、特性</h3><ul><li>唯一性：一个APP只允许有一个Glance控制器</li><li>实时性：及时更新Glance，以避免Glance展示出过期信息</li><li>聚焦性：在Glance上永远都只展示最重要的数据</li><li>只读性：Glance是只读的，不能与用户操作进行交互</li><li>基于模板：Glance是基于模板设计的，且Glance的界面范围仅限于单个屏幕</li></ul><h3 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h3><p>　　Glance界面控制器的生命周期和其他WatchKit界面控制器类似，不过Glance的界面控制器的初始化要更早，以便于Glance能快速的显示给用户。为确保展示的信息是最新的，需要在willActivate方法中包含检查方法，以避免Glance展示出过时的信息。</p><p>　　在WatchKit的启动顺序链中，WatchKit会自动针对当前的场景创建适用的controller，如果用户正在查看弹出的Glance，则创建Glance关联的controller；如果用户直接启动watch app，则WatchKit会从storyboard中载入对应的初始化controller。<br>　　<br>　　以上controller均由一个<code>WKInterfaceController</code>的子类进行管理，以下是其关键方法：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>initWithContext:</td><td>controller初始化方法</td></tr><tr><td>willActivate</td><td>UI加载完毕后调用</td></tr><tr><td>didDeactivate</td><td>watch app运行完毕即将失效前调用</td></tr></tbody></table><blockquote><p>注意：一旦<code>willActivate</code>被调用，则controller中的所有属性操作都将变得不可用，因此不能在<code>willActivate</code>中进行属性设置。（使timer无效化或者停止动画之类的操作是可以的）  </p></blockquote><h3 id="三、Glance界面"><a href="#三、Glance界面" class="headerlink" title="三、Glance界面"></a>三、Glance界面</h3><h4 id="1-接入点"><a href="#1-接入点" class="headerlink" title="1.接入点"></a>1.接入点</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/Art/glance_interface.png" alt="EntryPoint" title="">                </div>                <div class="image-caption">EntryPoint</div>            </figure><p>　　与传统iOS App在stroyboard中的表现类似，在增加WatchKit的target，并包含Glance之后，storyboard将会为Glance准备好UI界面与接入点。</p><h4 id="2-Glance-Interface-Controller"><a href="#2-Glance-Interface-Controller" class="headerlink" title="2.Glance Interface Controller"></a>2.Glance Interface Controller</h4><p>Glance对应的Glance Interface Controller是<code>WKInterfaceController</code>的子类，其主要功能是为Glance配置布局，因此其实现也非常简单，主要包括以下两个方法：</p><ol><li><p><code>initWithContext</code>:用于初始化Glance</p></li><li><p><code>willActivate</code>:用于更新Glance的UI界面</p></li></ol><p>当需要改动已经展示在屏幕上的UI元素时，我们可以使用<code>NSTimer</code>对象，或使用WatchKit中新加入的如<code>WKInterfaceDat</code>和<code>WKInterfaceTimer</code>等对象来对时间和计时进行操作。</p><h4 id="3-自定义Glance启动界面"><a href="#3-自定义Glance启动界面" class="headerlink" title="3.自定义Glance启动界面"></a>3.自定义Glance启动界面</h4><p>在WatchKit中，当用户点击弹出的Glance时默认为打开Watch App并展示main interface controller管理的界面。我们可以在Glance的controller中调用<code>updateUserActivity:userInfo:</code>方法，自定义从Glance启动后Watch app展示的界面，方法如下：</p><ol><li>glance interface controller</li></ol><ul><li><p>实现<code>initWithContext:</code>和<code>willActivate</code>方法。</p></li><li><p>调用<code>updateUserActivity:userInfo:</code>方法，传入userInfo参数。</p></li></ul><ol start="2"><li>main interface controller</li></ol><ul><li>实现<code>actionForUserActivity:context:</code>方法，根据传入的userInfo参数展示对应的interface controller，生产一个comtex对象并把它传入interface controller。</li></ul><h4 id="4-其他注意事项"><a href="#4-其他注意事项" class="headerlink" title="4.其他注意事项"></a>4.其他注意事项</h4><ul><li>Glance底部区域是留给页面指示器圆点的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Apple-Watchkit（Glance部分）&quot;&gt;&lt;a href=&quot;#Apple-Watchkit（Glance部分）&quot; class=&quot;headerlink&quot; title=&quot;Apple Watchkit（Glance部分）&quot;&gt;&lt;/a&gt;Apple Watchkit（Glance部分）&lt;/h1&gt;&lt;p&gt;Glance在英语中的字面意思是（一瞥;一滑;闪光），由此可见在WatchKit的UI体系中，Glance担负的任务是为用户提供实时快捷，简单明了的信息获取窗口。对Watch app来说，Glance是可选项，开发者可以选择性的对其进行实现。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/%E6%96%B0%E5%B9%B4%E5%89%8D%E5%A4%95%EF%BC%8C%E6%9D%A5%E8%87%AA%E8%8B%B9%E6%9E%9C%E7%9A%84%E7%A4%BC%E7%89%A9/"/>
    <id>https://www.akringblog.com/2017/04/07/新年前夕，来自苹果的礼物/</id>
    <published>2017-04-07T10:03:18.556Z</published>
    <updated>2017-04-19T07:49:29.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新年前夕，来自苹果的礼物"><a href="#新年前夕，来自苹果的礼物" class="headerlink" title="新年前夕，来自苹果的礼物"></a>新年前夕，来自苹果的礼物</h1><p><img src="http://akring-blog-image.qiniudn.com/2014.1.29/blog/1.png" alt="image"></p><p>在折腾了快2个月，先后因为各种原因被拒3次之后，我的第一个APP终于在APP Store上线了。再过两天就是马年新年了，也算是苹果在我本命年前送来的一份礼物吧，虽然过程充满曲折和艰辛，但总算是迈出了第一步。<br>在此也顺便分享一下从这次曲折的审核汲取的经验和教训。</p><a id="more"></a><h2 id="A、熟悉规则是成功的开始"><a href="#A、熟悉规则是成功的开始" class="headerlink" title="A、熟悉规则是成功的开始"></a>A、熟悉规则是成功的开始</h2><p>苹果为开发者提供了一份详细的审核文档:<a href="http://akring-blog-image.qiniudn.com/2014.1.29/blog/%E6%9C%80%E6%96%B02013%E5%B9%B4Appstore%E5%BA%94%E7%94%A8%E5%AE%A1%E6%A0%B8%E6%8C%87%E5%8D%97.doc" target="_blank" rel="noopener">2013最新审核规则</a> 建议所有准备提交审核的工程师们都仔细逐条的阅读，不要嫌麻烦，否则将来可能会给你的审核带来很多问题。</p><ul><li style="list-style: none"><input type="checkbox" checked> 例子：之前因为阅读文档不仔细，没有注意到苹果对程序内图标的限制，最终因为我使用了一个类似系统APP的方形圆角图标而被拒，这是第一次应用被拒。</li></ul><h2 id="B、良好的后勤保障是成功的基石"><a href="#B、良好的后勤保障是成功的基石" class="headerlink" title="B、良好的后勤保障是成功的基石"></a>B、良好的后勤保障是成功的基石</h2><p>在应用进入“In review”阶段之后，与APP相关的一切都要尽力维持稳定，包括但不限于数据库，服务器等等，如果使用类似云服务器等设备，需要特别关注在审核期间提供商是否有维护或其他可能导致app与服务器无法连接的活动，尽力避免因一些意外情况导致审核失败。</p><ul><li style="list-style: none"><input type="checkbox" checked> 例子：我的app后两次审核失败均是由于“In review”期间服务器崩溃，导致app无法连接服务器，被苹果审核组判定为存在致命bug，直接被拒。（另：不知苹果是否会进行压力测试，怀疑服务器崩溃与此有关）。</li></ul><h2 id="C、细节决定成败"><a href="#C、细节决定成败" class="headerlink" title="C、细节决定成败"></a>C、细节决定成败</h2><p>在严格遵循APP Store的审核规则之余，还需要注意一些细枝末节的细节问题，否则很可能阴沟里翻船。</p><ul><li><p>[x] 例子1：如果app需要登录以后才能测试和操作，那么切记：一定要提供测试帐号！，不要以为“我有提供注册功能啊！”而忽视这个问题，苹果的老爷们是不会乖乖按照你预想的流程来测试的，所以如果你忘了，那么只能下次再来了.</p></li><li><p>[x] 例子2：当app内涉及到一些你或你公司独有的流程的时候，例如你们有一个自己的积分系统，苹果审核人员可能会因为搞不明白积分从何而来，通过什么样的方法可以获得积分，积分有什么用等等而需要你提供一些说明信息，千万不要以为自己的应用是被拒了，这时候只需要提供一个详细说明，审核流程依然会继续往下走的。最好是在提交审核的时候在附加信息里提前注明，有备无患。</p></li></ul><p>最后说下申诉，申诉的速度比较慢，所以在申诉之前要先考虑好，如果比较有把握就提交申诉，如果确实是自己的问题建议不要抱有侥幸心理理，重新上传程序吧，等待申诉的时间也会耗去大约3-5天，抱有侥幸心理除了拖长审核周期以外没有任何帮助。</p><p>以上就是本次审核所获得的经验，与大家共享。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;新年前夕，来自苹果的礼物&quot;&gt;&lt;a href=&quot;#新年前夕，来自苹果的礼物&quot; class=&quot;headerlink&quot; title=&quot;新年前夕，来自苹果的礼物&quot;&gt;&lt;/a&gt;新年前夕，来自苹果的礼物&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://akring-blog-image.qiniudn.com/2014.1.29/blog/1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;在折腾了快2个月，先后因为各种原因被拒3次之后，我的第一个APP终于在APP Store上线了。再过两天就是马年新年了，也算是苹果在我本命年前送来的一份礼物吧，虽然过程充满曲折和艰辛，但总算是迈出了第一步。&lt;br&gt;在此也顺便分享一下从这次曲折的审核汲取的经验和教训。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/ZXING%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%A4%8D%E6%89%AB%E6%8F%8F/"/>
    <id>https://www.akringblog.com/2017/04/07/ZXING二维码实现重复扫描/</id>
    <published>2017-04-07T10:03:03.030Z</published>
    <updated>2017-04-07T10:03:09.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZXING二维码实现重复扫描"><a href="#ZXING二维码实现重复扫描" class="headerlink" title="ZXING二维码实现重复扫描"></a>ZXING二维码实现重复扫描</h1><p>ZXING是一个完全开放源码的开源项目，相比ZBAR的API开放，ZXING可定制性非常强。以下是实现ZXING完成一次扫描识别处理后，不退出扫描界面，继续准备下一次扫描的实现代码。</p><a id="more"></a><p>###在ZXingWidgetController.h中添加以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)reset;</span><br></pre></td></tr></table></figure><p>###在ZXingWidgetController.m中编写以上方法的实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)reset</span><br><span class="line">&#123;</span><br><span class="line">    decoding = YES;</span><br><span class="line">    [overlayView setPoints:nil];</span><br><span class="line">    wasCancelled = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###在你的ZXING处理返回值的回调函数中添加第5行的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)zxingController:(ZXingWidgetController *)controller didScanResult:(NSString *)result</span><br><span class="line">&#123;</span><br><span class="line">    //处理返回值的方法</span><br><span class="line">                  </span><br><span class="line">    [controller reset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且切记，以上方法的末尾别调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self dismissModalViewControllerAnimated:NO]</span><br></pre></td></tr></table></figure><blockquote><p>IOS7 中dismissModalView方法添加了一个block来执行dismiss后的一些额外操作，读者请自行参阅文档修改</p></blockquote><p>这会使ZXING扫描界面被弹出。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ZXING二维码实现重复扫描&quot;&gt;&lt;a href=&quot;#ZXING二维码实现重复扫描&quot; class=&quot;headerlink&quot; title=&quot;ZXING二维码实现重复扫描&quot;&gt;&lt;/a&gt;ZXING二维码实现重复扫描&lt;/h1&gt;&lt;p&gt;ZXING是一个完全开放源码的开源项目，相比ZBAR的API开放，ZXING可定制性非常强。以下是实现ZXING完成一次扫描识别处理后，不退出扫描界面，继续准备下一次扫描的实现代码。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/%E4%BD%BF%E7%94%A8UIImageWriteToSavedPhotosAlbum%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E7%9B%B8%E5%86%8C/"/>
    <id>https://www.akringblog.com/2017/04/07/使用UIImageWriteToSavedPhotosAlbum保存图片到相册/</id>
    <published>2017-04-07T10:02:48.823Z</published>
    <updated>2017-04-07T10:02:55.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用UIImageWriteToSavedPhotosAlbum保存图片到相册"><a href="#使用UIImageWriteToSavedPhotosAlbum保存图片到相册" class="headerlink" title="使用UIImageWriteToSavedPhotosAlbum保存图片到相册"></a>使用UIImageWriteToSavedPhotosAlbum保存图片到相册</h1><p><strong>遇到项目中需要将网络获取的图片存到IOS设备的相册中的时候，可以使用UIImageWriteToSavedPhotosAlbum，方法如下：</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将获取到的图片转化为UIImage</span><br><span class="line">UIImage *img = [UIImage imageNamed:@&quot;获取到的图片.png&quot;];  </span><br><span class="line">                       </span><br><span class="line">//将图片img保存到相册中</span><br><span class="line">UIImageWriteToSavedPhotosAlbum(img, self, @selector(image:didFinishSavingWithError:contextInfo:), nil);</span><br></pre></td></tr></table></figure><p>上述UIImageWriteToSavedPhotosAlbum中，</p><ul><li><p>img：为需要存储的照片(UIImage形式)的名称。</p></li><li><p>self：为相关delegate的目标</p></li><li><p>@selector：为存储图片操作进行后的回调方法，用于对操作结果进行输出和后续操作</p></li><li><p>nil：为传递的参数</p></li></ul><hr><p>以下为回调方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo&#123;</span><br><span class="line">           </span><br><span class="line">    if (error != NULL)&#123;             //判断存储操作是否成功？</span><br><span class="line">               </span><br><span class="line">      //存储失败，可输出相应的错误信息提示用户</span><br><span class="line">           </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">           </span><br><span class="line">      //存储成功，输出成功提示</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong> 注意：参照苹果官方开发文档，该回调方法的形式必须是上面的 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo</span><br></pre></td></tr></table></figure></p><p>_ 形式，否则回调时会引起错误，切记！_</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用UIImageWriteToSavedPhotosAlbum保存图片到相册&quot;&gt;&lt;a href=&quot;#使用UIImageWriteToSavedPhotosAlbum保存图片到相册&quot; class=&quot;headerlink&quot; title=&quot;使用UIImageWriteToSavedPhotosAlbum保存图片到相册&quot;&gt;&lt;/a&gt;使用UIImageWriteToSavedPhotosAlbum保存图片到相册&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;遇到项目中需要将网络获取的图片存到IOS设备的相册中的时候，可以使用UIImageWriteToSavedPhotosAlbum，方法如下：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/IOS%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://www.akringblog.com/2017/04/07/IOS代码中使用十六进制颜色的方法/</id>
    <published>2017-04-07T10:02:30.313Z</published>
    <updated>2017-04-19T07:45:58.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IOS代码中使用十六进制颜色的方法"><a href="#IOS代码中使用十六进制颜色的方法" class="headerlink" title="IOS代码中使用十六进制颜色的方法"></a>IOS代码中使用十六进制颜色的方法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在IOS开发过程中，用代码生成控件时经常需要涉及到为控件设定字体颜色，背景色等，IOS中为我们提供了UIColor类，但是其中包含的颜色仅只有一些基本的红(RedColor)绿(GreenClolr)蓝(BlueColor)等，使用起来无法满足我们的需要，因此我们一般会使用其他的方式来设定颜色</p><a id="more"></a><h2 id="使用RGB颜色"><a href="#使用RGB颜色" class="headerlink" title="使用RGB颜色"></a>使用RGB颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">UILabel *label;</span><br><span class="line">    </span><br><span class="line">[label setBackgroundColor:[UIColor colorWithRed:25/255 green:30/255 blue:70/255 alpha:1]];</span><br></pre></td></tr></table></figure><p>以上代码中通过设定RGB来实现自定义颜色，其参数如下：</p><ul><li><p>[ ] Red:红色值，格式必须为xx/255，或者对应的小数，如：255/255 和 1具有相同的效果</p></li><li><p>[ ] green:绿色值，注意事项同上</p></li><li><p>[ ] blue:蓝色值，注意事项同上</p></li><li><p>[ ] alpha:透明度，介于0-1之间的小数</p></li></ul><h2 id="使用十六进制颜色代码"><a href="#使用十六进制颜色代码" class="headerlink" title="使用十六进制颜色代码"></a>使用十六进制颜色代码</h2><p>在IOS代码中通过宏定义的方式，即可直接在程序中使用现成的十六进制代码，宏定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]</span><br></pre></td></tr></table></figure><p>将以上宏定义加入到实现文件的头部，在程序中需要使用十六进制颜色代码时直接调用即可。以下例子中使用的颜色代码为：#EDEDED，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UILabel *label;</span><br><span class="line"></span><br><span class="line">[label setBackgroundColor:UIColorFromRGB(0xEDEDED)];</span><br></pre></td></tr></table></figure><p>以上代码中通过设定十六进制颜色代码来实现自定义颜色，其参数如下：</p><ul><li><p>[ ] UIColorFromRGB:即之前的宏定义</p></li><li><p>[ ] (0xEDEDED):即将颜色代码<code>#EDEDED</code>的<code>#</code>号替换为“0x”即可</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以上方法，即可直接使用已经调好的十六进制颜色代码，省去了不断使用吸色器获取RGB颜色的过程，简化了代码，进而提高开发效率。</p><h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h3><p>以上宏定义来自<a href="http://beyondvincent.com" target="_blank" rel="noopener">船哥</a>的一篇博文，使用后发现非常好用，故将使用心得贴出。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IOS代码中使用十六进制颜色的方法&quot;&gt;&lt;a href=&quot;#IOS代码中使用十六进制颜色的方法&quot; class=&quot;headerlink&quot; title=&quot;IOS代码中使用十六进制颜色的方法&quot;&gt;&lt;/a&gt;IOS代码中使用十六进制颜色的方法&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在IOS开发过程中，用代码生成控件时经常需要涉及到为控件设定字体颜色，背景色等，IOS中为我们提供了UIColor类，但是其中包含的颜色仅只有一些基本的红(RedColor)绿(GreenClolr)蓝(BlueColor)等，使用起来无法满足我们的需要，因此我们一般会使用其他的方式来设定颜色&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/CoreData%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.akringblog.com/2017/04/07/CoreData使用小结/</id>
    <published>2017-04-07T10:02:05.796Z</published>
    <updated>2017-04-16T08:20:13.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CoreData使用小结"><a href="#CoreData使用小结" class="headerlink" title="CoreData使用小结"></a>CoreData使用小结</h1><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>CordData是IOS中独有的一种数据持久化方案，其本质还是通过操作SQLite数据库来完成数据存储，而CoreData的特色是将数据库操作变得更符合面向对象原则，简化了相关的操作。<br>最近在项目中使用到了CoreData进行数据持久化操作，以下是使用中的一些浅薄心得，写下来仅作新人参考，或博高手一笑。</p><a id="more"></a><p>###技术优势</p><blockquote><ol><li>使用CoreData无需书写任何SQL语句，对于简化代码，提高开发效率很有帮助。</li><li>将表视为实例，表中字段视为实例属性，与OC的面向对象一脉相承。</li><li>构建和修改数据库十分方便。</li></ol></blockquote><h1 id="二、开始使用CoreData"><a href="#二、开始使用CoreData" class="headerlink" title="二、开始使用CoreData"></a>二、开始使用CoreData</h1><p>首先在项目中加入”CoreData.framework”框架，如下图所示：</p><p><img src="http://akring-blog-image.qiniudn.com/coreData%E9%85%8D%E5%9B%BE%E6%A8%A1%E6%9D%BF%E5%88%9B%E5%BB%BA.png" alt="框架"></p><p>具体的Model文件创建，以及相应的Entity创建不再赘述，网上有大量文章详细介绍了相关内容。</p><p>###从模板创建</p><p>在创建工程时即勾选“Use Core Data”复选框，如下图所示：</p><p><img src="http://akring-blog-image.qiniudn.com/coreData%E9%85%8D%E5%9B%BE%E6%A1%86%E6%9E%B6.png" alt="模板创建"></p><p>即可在项目中启用CoreData。</p><p>###在已有项目中加入CoreData</p><p>在项目的appDelegate.h文件中加入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, retain, readonly) NSManagedObjectModel *managedObjectModel;</span><br><span class="line">@property (nonatomic, retain, readonly) NSManagedObjectContext *managedObjectContext;</span><br><span class="line">@property (nonatomic, retain, readonly) NSPersistentStoreCoordinator *persistentStoreCoordinator;</span><br><span class="line">@property (nonatomic, readonly) NSString *applicationDocumentsDirectory;</span><br></pre></td></tr></table></figure><p>在项目的appDelegate.m文件中加入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (NSManagedObjectContext *)managedObjectContext</span><br><span class="line">&#123;</span><br><span class="line">    if (managedObjectContext != nil) &#123;</span><br><span class="line">        return managedObjectContext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];</span><br><span class="line">    if (coordinator != nil) &#123;</span><br><span class="line">        managedObjectContext = [[NSManagedObjectContext alloc] init];</span><br><span class="line">        [managedObjectContext setPersistentStoreCoordinator:coordinator];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return managedObjectContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSManagedObjectModel *)managedObjectModel</span><br><span class="line">&#123;</span><br><span class="line">    if (managedObjectModel != nil) &#123;</span><br><span class="line">        return managedObjectModel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //从本地所有xcdatamodel文件中获得这个CoreData的数据模板</span><br><span class="line">    managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];</span><br><span class="line">    </span><br><span class="line">    return managedObjectModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSPersistentStoreCoordinator *)persistentStoreCoordinator</span><br><span class="line">&#123;</span><br><span class="line">    if (persistentStoreCoordinator != nil) &#123;</span><br><span class="line">        return persistentStoreCoordinator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSURL *storeUrl = [NSURL fileURLWithPath:[[self applicationDocumentsDirectory] stringByAppendingPathComponent:@&quot;OrderDB.sqlite&quot;]];//数据库名</span><br><span class="line">    </span><br><span class="line">    NSError *error;</span><br><span class="line">    persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (![persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeUrl options:nil error:&amp;error]) &#123;</span><br><span class="line">        NSAssert(0, @&quot;persistentStoreCoordinator init failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return persistentStoreCoordinator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)applicationDocumentsDirectory</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    NSString *basePath = ([paths count] &gt; 0) ? [paths objectAtIndex:0] : nil;</span><br><span class="line">    return basePath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中”OrderDB.sqlite”中的”OrderDB”即为对应的Model名称</p></blockquote><p>完成后，即可在项目中需要的地方通过Core Data对数据库进行操作。</p><h1 id="三、Core-Data的数据存取"><a href="#三、Core-Data的数据存取" class="headerlink" title="三、Core Data的数据存取"></a>三、Core Data的数据存取</h1><p>###使用Core Data存储数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Order *ord = (Order *)[NSEntityDescription insertNewObjectForEntityForName:@&quot;Order&quot; inManagedObjectContext:managedObjectContext];//Order为Entity名称</span><br><span class="line">    </span><br><span class="line">    int count = 2;</span><br><span class="line">    </span><br><span class="line">    //设置ord的各项实例属性</span><br><span class="line">    [ord setDishName:@&quot;水煮肉片&quot;;</span><br><span class="line">    [ord setDishClass:@&quot;川菜&quot;];</span><br><span class="line">    [ord setDishCount:count];</span><br><span class="line">    </span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    if (![managedObjectContext save:&amp;error ]) &#123;</span><br><span class="line">        // handle error</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>以上代码展示了向“菜单(order)”表中添加数据的过程</li><li>表（即Entity）实例名为：order</li><li>各字段（即实例属性为）：DishName（菜名），DishClass（菜系），DishCount（数量）。</li></ul></blockquote><p>###使用Core Data取出数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSFetchRequest *request = [[NSFetchRequest alloc] init];</span><br><span class="line">NSEntityDescription *entity = [NSEntityDescription entityForName:@&quot;Order&quot; inManagedObjectContext:managedObjectContext];</span><br><span class="line">[request setEntity:entity];</span><br><span class="line"></span><br><span class="line">//查询条件</span><br><span class="line">NSString *str = @:&quot;川菜&quot;;</span><br><span class="line"></span><br><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;dishClass = %@&quot;,str];</span><br><span class="line"></span><br><span class="line">[request setPredicate:predicate];//设置查询条件，即查询所有dishClass为川菜的数据</span><br><span class="line"></span><br><span class="line">//依照dishCount对查询结果排序</span><br><span class="line">NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@&quot;dishCount&quot; ascending:NO];</span><br><span class="line">NSArray *sortDescriptors = [[NSArray alloc] initWithObjects:sortDescriptor, nil];</span><br><span class="line"></span><br><span class="line">[request setSortDescriptors:sortDescriptors];</span><br><span class="line"></span><br><span class="line">NSError *error = nil;</span><br><span class="line">//获得一个包含order对象的数组</span><br><span class="line">NSMutableArray *mutableFetchResults = [[managedObjectContext executeFetchRequest:request error:&amp;error] mutableCopy];</span><br><span class="line"></span><br><span class="line">//遍历取出数据</span><br><span class="line">for (int j = 0;j &lt; mutableFetchResults.count; j++) &#123;</span><br><span class="line">    </span><br><span class="line">    Order *order = [mutableFetchResults objectAtIndex:j];</span><br><span class="line">    </span><br><span class="line">    NSString *name = order.dishName;</span><br><span class="line">    NSString *class = order.dishClass;</span><br><span class="line">    NSString *count = [NSString stringWithFormat:@&quot;%d&quot;,order.dishName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>以上代码展示了从“菜单(order)”表中获取数据的过程</li><li>表（即Entity）实例名为：Order</li><li>数组：mutableFetchResults为一个包含了所有order实例的数组</li><li>遍历数组：mutableFetchResults 即可取出对应的数据</li></ul></blockquote><h1 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h1><ol><li><p>在项目的appDelegate.m文件中加入的代码中<img src="http://akring-blog-image.qiniudn.com/coreData%E9%85%8D%E5%9B%BE%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5.png" alt="代码片段"><br>非常重要，它可以在程序异常退出时帮你完成数据库的保存工作。</p></li><li><p>无论是在使用模拟器调试，还是使用真机调试，当对数据库文件“XXX.xcdatamodeld”进行过修改后，需将IOS设备中的APP删除后重新Run，否则会报错。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CoreData使用小结&quot;&gt;&lt;a href=&quot;#CoreData使用小结&quot; class=&quot;headerlink&quot; title=&quot;CoreData使用小结&quot;&gt;&lt;/a&gt;CoreData使用小结&lt;/h1&gt;&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;CordData是IOS中独有的一种数据持久化方案，其本质还是通过操作SQLite数据库来完成数据存储，而CoreData的特色是将数据库操作变得更符合面向对象原则，简化了相关的操作。&lt;br&gt;最近在项目中使用到了CoreData进行数据持久化操作，以下是使用中的一些浅薄心得，写下来仅作新人参考，或博高手一笑。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/%E5%BE%80%E6%98%94%EF%BC%8C%E4%BB%8A%E5%A4%95%EF%BC%8C%E4%BD%95%E5%A4%95%EF%BC%9F/"/>
    <id>https://www.akringblog.com/2017/04/07/往昔，今夕，何夕？/</id>
    <published>2017-04-07T09:59:58.193Z</published>
    <updated>2017-04-07T10:00:06.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="往昔，今夕，何夕？"><a href="#往昔，今夕，何夕？" class="headerlink" title="往昔，今夕，何夕？"></a>往昔，今夕，何夕？</h1><h2 id="往昔"><a href="#往昔" class="headerlink" title="往昔"></a>往昔</h2><a id="more"></a><p>求学完业至今，二年有余矣。迷惘之时有之，耕耘之时有之，玩物丧志之时亦有之，个中之味，冷暖自知。<br>同窗之谊四载，而今散落天涯，再难一聚。然时值年少，未谙世事之险恶，不知其时之珍贵，恍悟于今，悔之晚矣。</p><h2 id="今夕"><a href="#今夕" class="headerlink" title="今夕"></a>今夕</h2><p>余本码农，砌码于春城，偏安一隅。然世事多舛，二易其主，实非吾愿，故知良主难遇，高薪显职，无过镜花水月，可寻溯而不可强求。</p><p>夫本命之年，诸多不顺。及至年中，与壕相协，欲辟新业，然中途夭折，不知所终。另有良机，亦踟蹰不前，终无所获。可慰者唯双亲之扶慰，亦得挚友相助，查缺补遗，多有裨益。其势愈艰，其心愈显，故知父母亲朋之佑爱，毕生难报矣。</p><h2 id="何夕？"><a href="#何夕？" class="headerlink" title="何夕？"></a>何夕？</h2><p>凡生所求何其多，非所需也，实不知足也。安康故吾愿，富贵未可期，明心之所欲，虽蹒跚前行，终不悔矣。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;往昔，今夕，何夕？&quot;&gt;&lt;a href=&quot;#往昔，今夕，何夕？&quot; class=&quot;headerlink&quot; title=&quot;往昔，今夕，何夕？&quot;&gt;&lt;/a&gt;往昔，今夕，何夕？&lt;/h1&gt;&lt;h2 id=&quot;往昔&quot;&gt;&lt;a href=&quot;#往昔&quot; class=&quot;headerlink&quot; title=&quot;往昔&quot;&gt;&lt;/a&gt;往昔&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/%E7%BA%AA%E5%BF%B5OBJC%E5%90%9B/"/>
    <id>https://www.akringblog.com/2017/04/07/纪念OBJC君/</id>
    <published>2017-04-07T09:59:35.247Z</published>
    <updated>2017-04-19T07:31:39.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="纪念OBJC君"><a href="#纪念OBJC君" class="headerlink" title="纪念OBJC君"></a>纪念OBJC君</h1><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>公元二零一四年六月四日，就是苹果召开WWDC后的那天，我独在公司内徘徊，遇见段君，前来问我道，“先生可曾为OBJC写了一点什么没有？”我说“没有”。她就正告我，“先生还是写一点罢；OBJC君生前先生就没为她写过什么文章。”<br><a id="more"></a><br>这是我知道的，凡我所编辑的博客，大概是因为往往有始无终之故罢，销行一向就甚为寥落，然而在这样的生活艰难中，毅然预定了我两个版面的就有她。我也早觉得有写一点东西的必要了。<br>可是我实在无话可说。我只觉得所住的并非人间。四千多个API的血，洋溢在我的周围，使我艰于呼吸视听，那里还能有什么言语？</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>真的码农，敢于直面惨淡的代码，敢于正视淋漓的BUG。这是怎样的哀痛者和幸福者？然而造化又常常为庸人设计，以时间的流驶，来洗涤注释，仅使留下淡红的异常和微漠的溢出。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>我在二日下午，才知道有苹果召开发布会的事；凌晨便得到噩耗，说苹果居然开枪，死伤至数千API，而OBJC君即在遇害者之列。但我对于这些传说，竟至于颇为怀疑。我向来是不惮以最坏的恶意，来推测苹果的，然而我还不料，也不信竟会下劣凶残到这地步。况且始终微笑着的和蔼的OBJC君，更何至于无端在会场前喋血呢？<br>然而即日证明是事实了，作证的便是她自己的尸骸。还有一具，是OpenGL君的。而且又证明着这不但是杀害，简直是谋杀，因为立刻就有小三取代了她们的地位。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>但是，我还有要说的话。</p><p>我没有亲见；听说她，OBJC君，那时是欣然前往的。自然，发布会而已，稍有人心者，谁也不会料到有这样的罗网。但竟在会场前中弹了，从背部入，斜穿心肺，已是致命的创伤，只是没有便死。同去的OpenGL君想扶起她，中了四弹，其一是膝盖，立仆；同去的Alfred君又想去扶起她，也被击，弹从左肩入，穿胸偏右出，也立仆。但她还能坐起来，一个Spotlight在她头部及胸部猛击两棍，于是死掉了。</p><p>始终微笑的和蔼的OBJC君确是死掉了，这是真的，有她自己的尸骸为证；沉勇而友爱的Alfred君也死掉了，有她自己的尸骸为证；只有一样沉勇而友爱的OpenGL君还在医院里呻吟。</p><p>苟活者在淡红的异常中，会依稀看见微茫的希望；真的码农，将更奋然而前行。</p><p>呜呼，我说不出话，但以此记念OBJC君！</p><p>六月四日</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;纪念OBJC君&quot;&gt;&lt;a href=&quot;#纪念OBJC君&quot; class=&quot;headerlink&quot; title=&quot;纪念OBJC君&quot;&gt;&lt;/a&gt;纪念OBJC君&lt;/h1&gt;&lt;h2 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h2&gt;&lt;p&gt;公元二零一四年六月四日，就是苹果召开WWDC后的那天，我独在公司内徘徊，遇见段君，前来问我道，“先生可曾为OBJC写了一点什么没有？”我说“没有”。她就正告我，“先生还是写一点罢；OBJC君生前先生就没为她写过什么文章。”&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/2014%E4%B8%8A%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://www.akringblog.com/2017/04/07/2014上半年总结/</id>
    <published>2017-04-07T09:59:02.345Z</published>
    <updated>2017-04-07T09:59:15.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2014上半年总结"><a href="#2014上半年总结" class="headerlink" title="2014上半年总结"></a>2014上半年总结</h1><p>新年过半，现将年初至今的工作及生活状况进行小结，以鞭策自己在下半年继续前行。</p><a id="more"></a><p>###一、生活方面</p><ol><li>体重比年初下降了接近10KG，很欣慰能有此成绩，当然中途的那次生病『功不可没』。自上高中以来第一次这么瘦过，感觉很好。</li><li>终于下定决心按揭购房了，明年底就可以搬进新家，打算在书房弄个落地窗，在35层高楼上看着城市夜景敲代码的感觉应该不错。当然与此同时经济压力也会比之前大很多，不过压力越大动力越大，下半年更要好好努力了。</li><li>不知是否是本命年的原因，上半年诸多不顺，中途又有买房之类的事情参合，以至于鲜少有时间和机会与亲友相聚交流，下半年一定要改正，人生在世，亲友不可抛。</li></ol><p>*</p><p>###二、工作方面</p><ol><li>四月初换了工作，原来的公司出了一些状况导致无法继续运营下去了，之前的项目就此夭折，对此感到比较遗憾，希望原来的团队队友们都能在新公司工作顺利。</li><li>和老段的合作项目做完了，包括iPhone端的APP和iPad端的后台（因为我不会做前端web开发……）。值得一提的是项目从头至尾都是我一个人扛，包括iPad后台的UI，从中获得了很多的经验和教训，也算是一段很有意思的经历。</li><li>游戏开发暂时陷入了瓶颈，因为Sprite Kit的开发资料实在是少之又少，而后续的构思和想法所需要的技术支撑已经远远超过我现在所有的技术能力，所以近段时间需要深入学习Sprite Kit的开发知识，做好技术储备，预计项目会在9-10月复工，争取年内完成。</li><li>近段时间还在准备做一个工具类应用，目前正在做界面UI的设计工作，该应用计划于今年内上线。</li></ol><hr><p>###三、学习方面</p><p>上半年是我经验槽飞涨的半年，主要技能点加在了以下几个方面：</p><ol><li>iOS开发技术，到目前为止今年开发了一款APP（iPad后台比较简单所以忽略不计），并预计在下半年完成1-2款，开发技术比起去年有比较大的提高。</li><li>UI设计技术，自从有了Sketch 3，妈妈再也不用担心我的界面丑如翔了。当然水平和专业设计师还有很大的差距，设计感和基本功是硬伤，需要花大量时间进一步学习和打磨。</li><li>后台开发技术，因为有云端后台的存在，这一块是我上半年投入最少的，下半年视进度和需要继续学习。</li></ol><p>*</p><p>###四、下半年计划</p><ol><li>学习Swift，因为目前objective-c依然是主流，以及Swift才刚刚发布，所以并未投入时间去学习Swift相关的内容，不过鉴于苹果发展Swift以取代objective-c的态度，尽早接受新鲜事物总是好的。</li><li>完成应用和APP。</li><li>保持健身，减肥如行舟，不进则退。</li></ol><p>总的来说，今年是压力和动力并存的一年，上半年过的多姿，期望下半年过的出彩。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2014上半年总结&quot;&gt;&lt;a href=&quot;#2014上半年总结&quot; class=&quot;headerlink&quot; title=&quot;2014上半年总结&quot;&gt;&lt;/a&gt;2014上半年总结&lt;/h1&gt;&lt;p&gt;新年过半，现将年初至今的工作及生活状况进行小结，以鞭策自己在下半年继续前行。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/AVOS%20Cloud%E5%88%9D%E6%8E%A2/"/>
    <id>https://www.akringblog.com/2017/04/07/AVOS Cloud初探/</id>
    <published>2017-04-07T09:58:39.116Z</published>
    <updated>2017-04-07T09:58:46.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVOS-Cloud初探"><a href="#AVOS-Cloud初探" class="headerlink" title="AVOS Cloud初探"></a>AVOS Cloud初探</h1><p>受朋友所托，需要快速开发一款原型APP供其餐厅使用，因受限于成本、人工及工期，后台开发成为了一件非常麻烦的事情，在仅有我一人开发的前提下同时兼顾前端和后端并不现实，因此我一直在寻找有没有其他更好的解决方案。在经过一段时间的寻找和测试之后，我找到了一款名为AVOS Cloud的BaaS，来完成后台支撑功能，下面将简要介绍一下其功能。（本文仅供自己记录及学习使用，非广告软文）</p><a id="more"></a><p>##安装<br>AVOS的安装非常友好，支持通过CocoaPods来进行安装，仅需在Podfile中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pod  &quot;AVOSCloud&quot;</span><br></pre></td></tr></table></figure><p>然后Pod Install即可</p><p>##使用存储功能<br>AVOS的IOS端API写的非常简洁优雅，近似于苹果官方API，使用起来非常舒服，下面以数据存储为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//保存数据到云端</span><br><span class="line">AVObject *finalGameScore = [AVObject objectWithClassName:@&quot;finalGameScore&quot;];</span><br><span class="line">[finalGameScore setObject:playerName forKey:@&quot;playerName&quot;];</span><br><span class="line">[finalGameScore setObject:[NSString stringWithFormat:@&quot;%d&quot;,score] forKey:@&quot;gameScore&quot;];</span><br><span class="line">[finalGameScore saveInBackground];</span><br></pre></td></tr></table></figure><p>这段代码将在AVOS云端创建一个finalGameScore类，并构造出一个AVObject对象，以面向对象的方式将数据存储到AVOS云端，非常简洁方便，同时AVOS还提供了saveInBackground等多个保存方法，可一行代码实现后台保存，断线重连自动保存等功能，极大提高开发效率</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AVOS-Cloud初探&quot;&gt;&lt;a href=&quot;#AVOS-Cloud初探&quot; class=&quot;headerlink&quot; title=&quot;AVOS Cloud初探&quot;&gt;&lt;/a&gt;AVOS Cloud初探&lt;/h1&gt;&lt;p&gt;受朋友所托，需要快速开发一款原型APP供其餐厅使用，因受限于成本、人工及工期，后台开发成为了一件非常麻烦的事情，在仅有我一人开发的前提下同时兼顾前端和后端并不现实，因此我一直在寻找有没有其他更好的解决方案。在经过一段时间的寻找和测试之后，我找到了一款名为AVOS Cloud的BaaS，来完成后台支撑功能，下面将简要介绍一下其功能。（本文仅供自己记录及学习使用，非广告软文）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/Mac%E4%B8%8B%E7%9A%84%E5%88%87%E5%9B%BE%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Slicy%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://www.akringblog.com/2017/04/07/Mac下的切图神器——Slicy使用说明/</id>
    <published>2017-04-07T09:57:36.767Z</published>
    <updated>2017-04-19T07:51:45.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac下的切图神器——Slicy使用说明"><a href="#Mac下的切图神器——Slicy使用说明" class="headerlink" title="Mac下的切图神器——Slicy使用说明"></a>Mac下的切图神器——Slicy使用说明</h1><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>切图作为美工出图的最后一步，向来都是令人头疼的工作，其工作内容繁琐枯燥，但又必不可少。同时，作为IOS开发者，我们往往需要为程序准备两套图片资源，以应对低清屏和Retina屏的不同需求，随之而来的是切图工作量的成倍增加。今天为大家推荐一款Mac下的切图小工具——Slicy，以上烦恼皆可得到妥善的解决。<br><a id="more"></a></p><blockquote><p>软件特性  </p><ol><li>切图方便，简单的拖放即可，傻瓜式操作2.   </li><li>培养为图片资源合理命名的好习惯  </li><li>自动生成@2x两套图片，极大方便IOS开发者  </li></ol></blockquote><h1 id="二、软件使用"><a href="#二、软件使用" class="headerlink" title="二、软件使用"></a>二、软件使用</h1><h2 id="1、PSD文件的预处理"><a href="#1、PSD文件的预处理" class="headerlink" title="1、PSD文件的预处理"></a>1、PSD文件的预处理</h2><blockquote><p>这一步可以由UI设计师来处理，不过个人推荐程序员亲自完成这一步骤，因为这里涉及到图片的命名，我们自己来对图片进行命名可以更好的使之符合整个项目的命名规则，方便在项目中对对应图片资源进行调用和管理。  </p></blockquote><p>首先用PhotoShop打开美工给你的PSD文件，如下图<br><img src="http://akring-blog-image.qiniudn.com/Slicy-BlogPSD%E5%8E%9F%E6%96%87%E4%BB%B6.png" alt="PSD原文件"><br>图中的绿色状态图标即为本次需要切出的素材图片</p><p>在右侧分组面板中，选中对应的组“Statues”</p><p><img src="http://akring-blog-image.qiniudn.com/Slicy-BlogPSD%E5%8E%9F%E5%88%86%E7%BB%84.png" alt="PSD原分组"></p><p>对“Statues”组的组名进行重命名，将其重命名为“<a href="mailto:Statues@2x.png" target="_blank" rel="noopener">Statues@2x.png</a>”，全部完成后保存PSD文件即可。</p><p><img src="http://akring-blog-image.qiniudn.com/Slicy-BlogPSD%E5%91%BD%E5%90%8D%E5%90%8E.png" alt="PSD命名后"></p><blockquote><p>这里要注意别忘了@2x后面的“.png”。同时，这里的命名即为图片素材被切出后的名字，因此建议大家在命名时考虑到项目整体的命名规则和调用的方便来进行命名，避免图片切好之后再来修改名字，浪费时间。  </p></blockquote><p>到这里，PSD文件的预处理就完成了，事实上这一步也是整个流程中比较繁琐的一步了，完成了这些，今天的切图工作就已经完成了八成。</p><h2 id="2、令人愉悦的切图工作"><a href="#2、令人愉悦的切图工作" class="headerlink" title="2、令人愉悦的切图工作"></a>2、令人愉悦的切图工作</h2><blockquote><p><strong>问：使用Slicy切图总共分几步？</strong>  </p></blockquote><blockquote><p><strong>答：总共分2步</strong>  </p></blockquote><blockquote><p><strong>第一步：把PSD拖进去</strong>  </p></blockquote><blockquote><p><strong>第二步：把图片拖出来</strong>  </p></blockquote><p>是的，就是如此简单，打开Slicy的主界面，你可以看到其主界面也是如此的简单。。。</p><p><img src="http://akring-blog-image.qiniudn.com/Slicy-BlogSlicy%E4%B8%BB%E7%95%8C%E9%9D%A2.png" alt="Slicy主界面"></p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>将我们预处理好的PSD文件拖进去，在一段令人愉悦的动画之后，我们会看到这个：</p><p><img src="http://akring-blog-image.qiniudn.com/Slicy-Blog%E6%8B%96%E6%94%BEPSD%E5%90%8E.png" alt="PSD拖放后"></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>按住Command + A快捷键全选，将图片拖到你需要的地方</p><p><img src="http://akring-blog-image.qiniudn.com/Slicy-Blog%E5%AF%BC%E5%87%BA%E5%90%8E.png" alt="PSD导出后"></p><p>可以看到，一套严格命名，大小合规的图片已经被切好导出了，就是这么简单！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Slicy的存在使得原本繁琐的切图工作变得轻松惬意，尤其是当程序猿霸气的对美工妹子说：“看你那么辛苦，今天的图我来切”时，相信大多数美工妹子都会感动的痛哭流涕有木有。。。<br>综上，Slicy使用简单，小巧清爽，实在是居家旅行，<del>杀人灭口</del>勾搭美工的必备神器。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac下的切图神器——Slicy使用说明&quot;&gt;&lt;a href=&quot;#Mac下的切图神器——Slicy使用说明&quot; class=&quot;headerlink&quot; title=&quot;Mac下的切图神器——Slicy使用说明&quot;&gt;&lt;/a&gt;Mac下的切图神器——Slicy使用说明&lt;/h1&gt;&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;切图作为美工出图的最后一步，向来都是令人头疼的工作，其工作内容繁琐枯燥，但又必不可少。同时，作为IOS开发者，我们往往需要为程序准备两套图片资源，以应对低清屏和Retina屏的不同需求，随之而来的是切图工作量的成倍增加。今天为大家推荐一款Mac下的切图小工具——Slicy，以上烦恼皆可得到妥善的解决。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/POP%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.akringblog.com/2017/04/07/POP框架开发浅析（一）/</id>
    <published>2017-04-07T09:57:14.194Z</published>
    <updated>2017-04-18T15:39:27.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="POP框架开发浅析（一）"><a href="#POP框架开发浅析（一）" class="headerlink" title="POP框架开发浅析（一）"></a>POP框架开发浅析（一）</h1><p>一直以来都比较纠结于iOS上的动画效果开发，平铺直叙的交互效果在当今扁平化遍地开花的年代显得太过苍白。私以为在扁平化设计中，动效和阴影的合理使用能够极大的提升APP的手感和吸引力，因此，学习iOS下的动画开发就显得非常有必要了。</p><a id="more"></a><h2 id="初识POP"><a href="#初识POP" class="headerlink" title="初识POP"></a>初识POP</h2><p>POP是由Facebook开源的一款动画引擎，曾被用于开发Facebook Paper，其特性可被概括为<strong>生动流畅，简单易用</strong>。通过POP引擎，我们可以为用户创造出逼真而充满物理效应的动效体验。</p><h3 id="安装与集成"><a href="#安装与集成" class="headerlink" title="安装与集成"></a>安装与集成</h3><p>POP可以通过Cocoapods或手动配置的方式集成到项目中，个人建议使用cocoapods的方式，其pod命令为：pod ‘pop’。未使用cocoapod的同学可以前往POP的<a href="https://github.com/facebook/pop" target="_blank" rel="noopener">Github页面</a>下载Zip压缩包后自行配置与集成。</p><h3 id="引入头文件"><a href="#引入头文件" class="headerlink" title="引入头文件"></a>引入头文件</h3><p>在项目中使用POP仅需引入POP.h头文件即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;pop/POP.h&gt;</span><br></pre></td></tr></table></figure></p><h2 id="动画类型"><a href="#动画类型" class="headerlink" title="动画类型"></a>动画类型</h2><p>POP默认提供两种动画类型——Spring和Decay，而在此基础上每种类型中又包含了多种动画模式。</p><h3 id="Spring-Animation-跳跃动画"><a href="#Spring-Animation-跳跃动画" class="headerlink" title="Spring Animation(跳跃动画)"></a>Spring Animation(跳跃动画)</h3><p>Spring单词的其中一个含义是弹簧，由此可见此类动画的主要特征就是像弹簧一般可以来回弹动，利用Spring Animation，我们可以创造出富有动感且符合物理规律的动画效果。<br>Spring Animation包含了以下5个主要参数；</p><ol><li>Bounciness(反弹)</li></ol><p>反弹主要影响动画所作用的参数的变化幅度，例如用作缩放动画时，可调节缩放的范围比例。</p><ol start="2"><li>Speed(速度)</li></ol><p>速度主要影响动画作用的时间，速度越慢，则动画从开始到结束所需的时间越长。</p><ol start="3"><li>Tension(拉力)</li></ol><p>拉力主要影响动画弹动的力度及速度，拉力越大则动画执行起来越干净利落，拉力越小则动画执行起来越和缓平滑，具体效果需自行调试后才能有直观的感受。</p><ol start="4"><li>Friction(摩擦力)</li></ol><p>摩擦力参数启用后，动画会不断重复，并且幅度逐渐削弱，直到停止，其效果类似于从桌上推落一只皮球，落地后不断弹起——落下，直至最终静止于地面的过程。摩擦力越大，则动画幅度削弱的越快，从开始到停止的时间也就越短。</p><ol start="5"><li>Mass(质量)</li></ol><p>质量会细微地影响动画的回弹力度和速度，在开启摩擦力参数时效果最为明显。</p><blockquote><p>各参数之间常会互相作用，建议大家都通过控制变量法，在demo上实际观察各项参数对动画效果的影响。</p></blockquote><h3 id="Decay-Animation-衰减动画"><a href="#Decay-Animation-衰减动画" class="headerlink" title="Decay Animation(衰减动画)"></a>Decay Animation(衰减动画)</h3><p>Decay Animation可以实现衰减的动画效果，其效果类似于汽车刹车，等同于物理概念中的匀变速运动。Decay Animation有一个非常重要的参数——velocity(速率)，其作用等同于物理匀变速运动公式中的加速度a。<br>例如：要创建一个物体移动的动画，那么我们可以为其X方向值设定初始值fromValue，然后设定速率velocity，则动画会从初始值以velocity的速率变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;POP框架开发浅析（一）&quot;&gt;&lt;a href=&quot;#POP框架开发浅析（一）&quot; class=&quot;headerlink&quot; title=&quot;POP框架开发浅析（一）&quot;&gt;&lt;/a&gt;POP框架开发浅析（一）&lt;/h1&gt;&lt;p&gt;一直以来都比较纠结于iOS上的动画效果开发，平铺直叙的交互效果在当今扁平化遍地开花的年代显得太过苍白。私以为在扁平化设计中，动效和阴影的合理使用能够极大的提升APP的手感和吸引力，因此，学习iOS下的动画开发就显得非常有必要了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.akringblog.com/2017/04/07/%E4%BF%AE%E6%94%B9UISearchBar%E8%BE%93%E5%85%A5%E6%A1%86%E8%83%8C%E6%99%AF%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://www.akringblog.com/2017/04/07/修改UISearchBar输入框背景的方法/</id>
    <published>2017-04-07T09:56:58.737Z</published>
    <updated>2017-04-07T09:57:04.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改UISearchBar输入框背景的方法"><a href="#修改UISearchBar输入框背景的方法" class="headerlink" title="修改UISearchBar输入框背景的方法"></a>修改UISearchBar输入框背景的方法</h1><p>在上古时期(iOS5)，修改UISearchBar的主要方法为：通过遍历UISearchbar的subView，找到负责输入的(UITextField )view，再修改其背景，达到定制UISearchBar背景的效果，苹果在iOS5后加入了新的接口，用于修改UISearchBar的textField的背景：</p><a id="more"></a><p><code>setSearchFieldBackgroundImage:forState:</code></p><p>将以上代码放入AppDelegate.m的ViewDidLoad方法中即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UISearchBar.appearance().setSearchFieldBackgroundImage(UIImage(named: &quot;搜索框背景&quot;), forState: UIControlState.Normal)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;修改UISearchBar输入框背景的方法&quot;&gt;&lt;a href=&quot;#修改UISearchBar输入框背景的方法&quot; class=&quot;headerlink&quot; title=&quot;修改UISearchBar输入框背景的方法&quot;&gt;&lt;/a&gt;修改UISearchBar输入框背景的方法&lt;/h1&gt;&lt;p&gt;在上古时期(iOS5)，修改UISearchBar的主要方法为：通过遍历UISearchbar的subView，找到负责输入的(UITextField )view，再修改其背景，达到定制UISearchBar背景的效果，苹果在iOS5后加入了新的接口，用于修改UISearchBar的textField的背景：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
