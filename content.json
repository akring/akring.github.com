{"meta":{"title":"Akring's Blog","subtitle":"Everything is permitted","description":"iOS / Mac Developer","author":"Akring","url":"https://www.akringblog.com"},"pages":[{"title":"categories","date":"2019-01-16T16:34:55.000Z","updated":"2019-01-17T02:58:09.951Z","comments":false,"path":"categories/index.html","permalink":"https://www.akringblog.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-16T16:34:46.000Z","updated":"2019-01-17T02:58:09.951Z","comments":false,"path":"tags/index.html","permalink":"https://www.akringblog.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flutter Card 中图片圆角显示","slug":"Flutter Card 中图片圆角显示","date":"2019-01-17T12:20:19.000Z","updated":"2019-01-20T11:13:48.022Z","comments":true,"path":"2019/01/17/Flutter Card 中图片圆角显示/","link":"","permalink":"https://www.akringblog.com/2019/01/17/Flutter Card 中图片圆角显示/","excerpt":"需在 Card 组件中显式申明：clipBehavior: Clip.antiAlias,，完整代码如下：","text":"需在 Card 组件中显式申明：clipBehavior: Clip.antiAlias,，完整代码如下： 123456789101112131415161718192021class _CardItemState extends State&lt;CardItem&gt; &#123; void _clicked() &#123;&#125; @override Widget build(BuildContext context) &#123; return Container( padding: EdgeInsets.all(10), // height: 200, child: new Card( clipBehavior: Clip.antiAlias, child: Column( children: &lt;Widget&gt;[ Image.asset( \"images/userBgImag.png\", // fit: BoxFit.cover, ), ], ), ), ); &#125;&#125;","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.akringblog.com/tags/Flutter/"}]},{"title":"iOS Moya 实现 OAuth 2.0 请求","slug":"iOS Moya 实现 OAuth 2.0 请求","date":"2019-01-08T13:30:21.000Z","updated":"2019-01-20T11:14:01.329Z","comments":true,"path":"2019/01/08/iOS Moya 实现 OAuth 2.0 请求/","link":"","permalink":"https://www.akringblog.com/2019/01/08/iOS Moya 实现 OAuth 2.0 请求/","excerpt":"0. 起源开放授权（OAuth）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。","text":"0. 起源开放授权（OAuth）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。而作为第三方软件，为用户提供 OAuth 登录是更好的选择，可以有效打消用户对于个人账户密码泄露的顾虑，同时也能有效避免用户反复登录，进而增加用户的舒适度，提高用户粘性。 1. 环境项目使用 MVVM 架构，引入了 Rx 全家桶，网络请求框架使用了 Moya，以及处理 Oauth 相关的库 OAuth2。 2. OAuth2 部分参阅 OAuth2 库的README，完成 OAuth 的信息配置：12345678910let oauth2 = OAuth2CodeGrant(settings: [ \"client_id\": \"my_swift_app\", \"client_secret\": \"C7447242\", \"authorize_uri\": \"https://github.com/login/oauth/authorize\", \"token_uri\": \"https://github.com/login/oauth/access_token\", // code grant only \"redirect_uris\": [\"myapp://oauth/callback\"], // register your own \"myapp\" scheme in Info.plist \"scope\": \"user repo:status\", \"secret_in_body\": true, // Github needs this \"keychain\": false, // if you DON'T want keychain integration] as OAuth2JSON) 同时因为 Moya 的底层网络请求实现是基于 Alamofire，因此我们可以参照 OAuth2 提供的说明文档 Alamofire 4 · p2/OAuth2 Wiki · GitHub 完成相关配置，关键代码如下：12345678910111213141516171819202122232425262728293031323334353637383940import Foundationimport OAuth2import Alamofireclass OAuth2RetryHandler: RequestRetrier, RequestAdapter &#123; let loader: OAuth2DataLoader init(oauth2: OAuth2) &#123; loader = OAuth2DataLoader(oauth2: oauth2) &#125; /// Intercept 401 and do an OAuth2 authorization. public func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: @escaping RequestRetryCompletion) &#123; if let response = request.task?.response as? HTTPURLResponse, 401 == response.statusCode, let req = request.request &#123; var dataRequest = OAuth2DataRequest(request: req, callback: &#123; _ in &#125;) dataRequest.context = completion loader.enqueue(request: dataRequest) loader.attemptToAuthorize() &#123; authParams, error in self.loader.dequeueAndApply() &#123; req in if let comp = req.context as? RequestRetryCompletion &#123; comp(nil != authParams, 0.0) &#125; &#125; &#125; &#125; else &#123; completion(false, 0.0) // not a 401, not our problem &#125; &#125; /// Sign the request with the access token. public func adapt(_ urlRequest: URLRequest) throws -&gt; URLRequest &#123; guard nil != loader.oauth2.accessToken else &#123; return urlRequest &#125; return try urlRequest.signed(with: loader.oauth2) // \"try\" added in 3.0.2 &#125;&#125; 3. Moya 部分Moya 的 provider 在初始化时可以传入 SessionManager ，因此参照文档，可以先使用 OAuth2 生成一个特定的 SessionManager ：12345678910111213141516171819func getManager() -&gt; SessionManager &#123; let oauth2 = OAuth2CodeGrant(settings: [ \"client_id\": \"my_swift_app\", \"client_secret\": \"C7447242\", \"authorize_uri\": \"https://github.com/login/oauth/authorize\", \"token_uri\": \"https://github.com/login/oauth/access_token\", // code grant only \"redirect_uris\": [\"myapp://oauth/callback\"], // register your own \"myapp\" scheme in Info.plist \"scope\": \"user repo:status\", \"secret_in_body\": true, // Github needs this \"keychain\": false, // if you DON'T want keychain integration ] as OAuth2JSON) let sessionManager = SessionManager() let oauthHandler = OAuth2Handler(oauth2: oauth2) sessionManager.adapter = oauthHandler sessionManager.retrier = oauthHandler return sessionManager &#125; 进而生成带 OAuth 的 provider：123fileprivate lazy var provider: MoyaProvider = &#123; return MoyaProvider&lt;API&gt;(manager: self.getManager(), plugins: [NetworkLoggerPlugin()]) &#125;() 使用使用生成的 provider发送请求即可，此时 Moya 可自动处理 OAuth 认证信息。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://www.akringblog.com/tags/Swift/"}]},{"title":"带参字符串国际化的一种写法","slug":"带参字符串国际化的一种写法","date":"2018-09-30T00:20:31.000Z","updated":"2019-01-20T11:25:08.272Z","comments":true,"path":"2018/09/30/带参字符串国际化的一种写法/","link":"","permalink":"https://www.akringblog.com/2018/09/30/带参字符串国际化的一种写法/","excerpt":"","text":"最近在为Star Order做中文本地化，其中涉及到对含参字符串做本地化的需求，参考写法如下: 原句: Are you sure to rename XXX 翻译句: 是否确定重命名 XXX XXX是一个字符串参数，用于接收传入的名称 代码如下: 1234NSString *localizedString = NSLocalizedString(@\"Rename\", nil);NSString *title = [NSString stringWithFormat:@\"%@ '%@'\",localizedString, 入参]; 简而言之，即将需要翻译的部分和参数部分分离即可. 在编辑Localizable.strings文件的时候，需要注意格式问题，例如&quot;Enter new tag name&quot; = &quot;输入新标签名&quot;;结尾的那个;漏掉的话会导致整个Localizable.strings文件失效，进而导致APP中引用了NSLocalizedString的地方统统失效，需要特别小心","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"Swift Lint 的配置和使用","slug":"Swift Lint 的配置和使用","date":"2018-07-20T08:20:31.000Z","updated":"2019-01-20T11:23:01.907Z","comments":true,"path":"2018/07/20/Swift Lint 的配置和使用/","link":"","permalink":"https://www.akringblog.com/2018/07/20/Swift Lint 的配置和使用/","excerpt":"","text":"一、安装个人倾向于使用 Homebre 直接安装在 Mac 上，无需对每个项目的 Podfile 做改动 1brew install swiftlint 完成安装后，\u0010还需要在项目中添加一个 Run Script，\b使每次 Build 都会自动调用 Swift Lint 作代码扫描和校正。 12345if which swiftlint &gt;/dev/null; then swiftlintelse echo \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"fi \b以上脚本的 else 分支会在当前设备未\b安装/配置 Swift Lint 的时候在控制台输出提示 二、Swift Lint 配置项目中可能会使用Cocoapods或Carthage引入了第三方库，如果不对 Swift Lint 加以配置，则会导致这部分第三方库也被纳入到代码检查的范围，这是我们不期望看到的。同时，如果你正在维护一个历史久远，可能从 Swfit 2 时期就存在的项目的话，打开 Swift Lint 之后你将可能看到 999+个红色的编译错误。同时大量修改代码，并确保功能不出问题，这对任何人来说应该都是极大的负担，在这种情况下，我们可能会期望暂时禁用某些规则，如force_cast，以便在确保项目正常编译的同时，渐进式的完成 Swfit Lint 的修改工作，而这一切都必须依赖于自定义的 .swiftlint.yml配置文件。 忽略文件在项目根目录下创建一个.swiftlint.yml文件： 1vim .swiftlint.yml 然后为其加入如下代码： 123excluded: # 你所希望不要检索的路径,SwiftLint会无视掉该路径下的文件 - Carthage - Pods 即可方便的忽略掉通过Cocoapods或Carthage引入的第三方库，如果项目中还有其他不想要做 Swift Lint 代码检查的文件或目录，也照此办理即可。 禁用规则在.swiftlint.yml中加入如下代码： 123disabled_rules: # 禁用指定的规则 - force_try - force_cast 即可禁用对应的规则","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://www.akringblog.com/tags/Swift/"}]},{"title":"Swift中单例的正确写法","slug":"Swift中单例的正确写法","date":"2017-12-20T08:20:31.000Z","updated":"2019-01-20T11:23:25.606Z","comments":true,"path":"2017/12/20/Swift中单例的正确写法/","link":"","permalink":"https://www.akringblog.com/2017/12/20/Swift中单例的正确写法/","excerpt":"","text":"12345678910import Cocoaclass UserInfoContex: NSObject &#123; static let sharedInstance = UserInfoContex() private override init() &#123; &#125;&#125; 通过设置初始化方法为私有，可以有效保证单例是真正唯一的，避免外部对象通过访问init方法创建单例类的其他实例。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://www.akringblog.com/tags/Swift/"}]},{"title":"Mac自定义标题栏响应双击Zoom的方法","slug":"Mac自定义标题栏响应双击Zoom的方法","date":"2017-02-08T13:30:21.000Z","updated":"2019-01-20T11:19:22.867Z","comments":true,"path":"2017/02/08/Mac自定义标题栏响应双击Zoom的方法/","link":"","permalink":"https://www.akringblog.com/2017/02/08/Mac自定义标题栏响应双击Zoom的方法/","excerpt":"","text":"在之前的博文中我们实现了类似Reminder的实现：《自定义Mac标题栏样式》 然而，使用以上方法实现自定义标题栏，会带来一个额外的副作用：双击Title bar无法再实现默认Window的Zoom效果，即无法自动缩放窗口到全屏效果。 发现这个问题后我测试了Mac自带的Reminder应用，发现同样具有这个问题，由此可见这也许是一个OS X的 Bug，或是一个人所未知的“feature”。Anyway， 为了解决这个问题，我使用了一个比较非主流的方式，记录如下。 一、总体思路通过查看文档和Storyboard文件，作为First Responder的Window具有一个叫做performZoom的方法，而通过触发这个方法，Window就会执行缩放操作。如此一来，问题的解决方案可以归为： 响应双击事件 判定点击区域是否在title bar内 执行performZoom进行缩放 二、具体实现1. 响应双击事件通过覆写mouseDown(with event: NSEvent)方法，检测鼠标点击事件，实现代码如下： 12345678override func mouseDown(with event: NSEvent) &#123; if (event.clickCount &gt; 1) &#123; //双击相关处理 &#125; else&#123; super.mouseDown(with: event) &#125; &#125; 2. 判定点击区域是否在title bar内通过event检测鼠标点击的位置，并进一步通过func convert(_ point: NSPoint, to view: NSView?) -&gt; NSPoint方法将点击点映射到目的View上，从而检测是否点击到了所需的View上。代码如下： 1234let location = self.view.convert(event.locationInWindow, to: statusBar) if (location.x &gt;= 0 &amp;&amp; location.y &gt;= 0) &#123;//即点击点位于statusBar内部 //执行操作 &#125; 3. 执行performZoom进行缩放执行Zoom操作： 1self.view.window?.performZoom(nil) 完整代码如下： 12345678910111213override func mouseDown(with event: NSEvent) &#123; if (event.clickCount &gt; 1) &#123; //双击相关处理 let location = self.view.convert(event.locationInWindow, to: statusBar) if (location.x &gt;= 0 &amp;&amp; location.y &gt;= 0) &#123;//即点击点位于statusBar内部 self.view.window?.performZoom(nil) &#125; &#125; else&#123; super.mouseDown(with: event) &#125; &#125; 三、相关思考其实一开始使用这样的方法我是拒绝的，因为怎么看都有一种 -钦定- 黑魔法的感觉。然而在有了比较多的Mac开发经历之后，我对此已经见怪不怪了。相比iOS， Mac开发总是需要subclass更多，hack更多。 除此之外，对知名应用Omnifocus的观察也让我觉得，这很可能是一条可行的路线，通过观察Omnifocus的行为，我发现其相应双击Zoom的响应区域更大，如下图： 他的整个Tool Bar 和 Title Bar都可以响应双击事件，而根据我的解决方案，只需要将双击判定区域扩大到整个Tool Bar，即可轻松实现这个效果。再对比官方Reminders完全无法Zoom的行为，依然觉得Apple还得多加努力啊。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://www.akringblog.com/tags/Swift/"},{"name":"Mac","slug":"Mac","permalink":"https://www.akringblog.com/tags/Mac/"}]},{"title":"自定义Mac标题栏样式","slug":"自定义Mac标题栏样式","date":"2017-01-22T03:30:21.000Z","updated":"2019-01-20T11:19:59.939Z","comments":true,"path":"2017/01/22/自定义Mac标题栏样式/","link":"","permalink":"https://www.akringblog.com/2017/01/22/自定义Mac标题栏样式/","excerpt":"","text":"与默认的Mac APP标题栏相比，类似Mac原生应用Reminder的标题栏具有更好的显示效果，标题栏和下方的Content View有效融合，整体风格能够保持一致。 而要实现这种风格，我们只需要对当前NSWindow做如下处理： 1self.titlebarAppearsTransparent = true 对于这个属性，Apple官方文档里是这样解释的： When the value of this property is true, the title bar does not draw its background, which allows all content underneath it to show through. It only makes sense to set this property to true when NSFullSizeContentViewWindowMask is also set. 当titlebarAppearsTransparent设为true的时候，title bar将不会绘制其背景，换而言之，title bar将会变成透明的，使其完全和下面的View融为一体。 与此同时，Apple还提到，将这个属性设置为true的同时，我们还需要设置Window的NSFullSizeContentViewWindowMask，如以下代码所示： 1self.styleMask = [.fullSizeContentView] 本文涉及的完整代码如下：1234567891011121314class MainWindow: NSWindow &#123; override func awakeFromNib() &#123; super.awakeFromNib() self.title = \"Star Order\" self.styleMask = [.fullSizeContentView, .titled, .miniaturizable, .resizable, .closable] self.titlebarAppearsTransparent = true Utils.positionWindowAtCenter(sender: self) &#125;&#125;","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://www.akringblog.com/tags/Swift/"},{"name":"Mac","slug":"Mac","permalink":"https://www.akringblog.com/tags/Mac/"}]},{"title":"iOS检测手机蜂窝网络制式","slug":"Mac OS 下字符串复制到剪贴板","date":"2016-06-12T04:30:21.000Z","updated":"2019-01-20T11:17:45.858Z","comments":true,"path":"2016/06/12/Mac OS 下字符串复制到剪贴板/","link":"","permalink":"https://www.akringblog.com/2016/06/12/Mac OS 下字符串复制到剪贴板/","excerpt":"Mac OS 下字符串复制到剪贴板","text":"Mac OS 下字符串复制到剪贴板 123456789101112/** 复制Clone地址到剪贴板 - parameter sender: */@IBAction func copyCloneAddressToPastBord(sender:NSButton) &#123; let string = repoCloneLabel.stringValue NSPasteboard.generalPasteboard().declareTypes([NSStringPboardType], owner: self) NSPasteboard.generalPasteboard().setString(string, forType: NSStringPboardType)&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://www.akringblog.com/tags/Swift/"}]},{"title":"Apple Watchkit（Glance部分）","slug":"Apple Watchkit（Glance部分）","date":"2016-04-08T04:00:59.000Z","updated":"2019-01-20T11:08:37.643Z","comments":true,"path":"2016/04/08/Apple Watchkit（Glance部分）/","link":"","permalink":"https://www.akringblog.com/2016/04/08/Apple Watchkit（Glance部分）/","excerpt":"Glance在英语中的字面意思是（一瞥;一滑;闪光），由此可见在WatchKit的UI体系中，Glance担负的任务是为用户提供实时快捷，简单明了的信息获取窗口。对Watch app来说，Glance是可选项，开发者可以选择性的对其进行实现。","text":"Glance在英语中的字面意思是（一瞥;一滑;闪光），由此可见在WatchKit的UI体系中，Glance担负的任务是为用户提供实时快捷，简单明了的信息获取窗口。对Watch app来说，Glance是可选项，开发者可以选择性的对其进行实现。 一、特性 唯一性：一个APP只允许有一个Glance控制器 实时性：及时更新Glance，以避免Glance展示出过期信息 聚焦性：在Glance上永远都只展示最重要的数据 只读性：Glance是只读的，不能与用户操作进行交互 基于模板：Glance是基于模板设计的，且Glance的界面范围仅限于单个屏幕 二、生命周期 Glance界面控制器的生命周期和其他WatchKit界面控制器类似，不过Glance的界面控制器的初始化要更早，以便于Glance能快速的显示给用户。为确保展示的信息是最新的，需要在willActivate方法中包含检查方法，以避免Glance展示出过时的信息。 在WatchKit的启动顺序链中，WatchKit会自动针对当前的场景创建适用的controller，如果用户正在查看弹出的Glance，则创建Glance关联的controller；如果用户直接启动watch app，则WatchKit会从storyboard中载入对应的初始化controller。 以上controller均由一个WKInterfaceController的子类进行管理，以下是其关键方法： 方法名 作用 initWithContext: controller初始化方法 willActivate UI加载完毕后调用 didDeactivate watch app运行完毕即将失效前调用 注意：一旦willActivate被调用，则controller中的所有属性操作都将变得不可用，因此不能在willActivate中进行属性设置。（使timer无效化或者停止动画之类的操作是可以的） 三、Glance界面1.接入点 EntryPoint 与传统iOS App在stroyboard中的表现类似，在增加WatchKit的target，并包含Glance之后，storyboard将会为Glance准备好UI界面与接入点。 2.Glance Interface ControllerGlance对应的Glance Interface Controller是WKInterfaceController的子类，其主要功能是为Glance配置布局，因此其实现也非常简单，主要包括以下两个方法： initWithContext:用于初始化Glance willActivate:用于更新Glance的UI界面 当需要改动已经展示在屏幕上的UI元素时，我们可以使用NSTimer对象，或使用WatchKit中新加入的如WKInterfaceDat和WKInterfaceTimer等对象来对时间和计时进行操作。 3.自定义Glance启动界面在WatchKit中，当用户点击弹出的Glance时默认为打开Watch App并展示main interface controller管理的界面。我们可以在Glance的controller中调用updateUserActivity:userInfo:方法，自定义从Glance启动后Watch app展示的界面，方法如下： glance interface controller 实现initWithContext:和willActivate方法。 调用updateUserActivity:userInfo:方法，传入userInfo参数。 main interface controller 实现actionForUserActivity:context:方法，根据传入的userInfo参数展示对应的interface controller，生产一个comtex对象并把它传入interface controller。 4.其他注意事项 Glance底部区域是留给页面指示器圆点的。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"}]},{"title":"Origami初步教程","slug":"Origami初步教程","date":"2016-03-28T08:20:31.000Z","updated":"2019-01-20T11:21:54.458Z","comments":true,"path":"2016/03/28/Origami初步教程/","link":"","permalink":"https://www.akringblog.com/2016/03/28/Origami初步教程/","excerpt":"Origami是Facebook推出的，结合了自家POP动画引擎的原型交互设计套件，通过简单的拖拽和连线，即可创建出效果不错的动画。而Origami 2.0版本中引入的Code Export代码导出功能，对具体参与编码的工程师来说更是一大福音，从根本上解决了UX交互设计师设计的动画效果和软件工程师实现的效果不匹配的问题。","text":"Origami是Facebook推出的，结合了自家POP动画引擎的原型交互设计套件，通过简单的拖拽和连线，即可创建出效果不错的动画。而Origami 2.0版本中引入的Code Export代码导出功能，对具体参与编码的工程师来说更是一大福音，从根本上解决了UX交互设计师设计的动画效果和软件工程师实现的效果不匹配的问题。 Origami的使用并不复杂，尤其是对于经常和Interface Builder（如XIB，Storyboard）打交道的iOS工程师来说更是容易上手，以下将用Origami实现一个简单的针对图片的旋转缩放效果，并演示如何将设计的效果移植到我们实际的工程中。 重要提示： 截止目前，我使用的Origami版本为2.0.2，这个版本中存在一个需要注意的问题，就是在设置动画的时候只有当你使用了POPAnimation组件，才可以顺利的完成Code Export代码导出，否则你将会得到一个空白的代码文件。 一、搭建文件结构1. 新建一个Origami文件 2. 新建的文件结构如图： 左侧的Viewer Size用于控制预览器的外观，基本覆盖了iOS_Android_Windows Phone等平台，根据需要自行调整 3. 双击中部的Layer Group进入内部，所有的动画配置都在这个部件中进行，初始的结构如图： 二、构建动画链1. 从Library中选取Interaction2组件，拖动到主窗口： Interaction2组件是Facebook自行封装的一个组件，用于模拟触摸屏上的点击，滑动等操作动作，是整个动画的入口。 2. 选取一张图片，拖动到主窗口，创建一个Image Layer： 这个Image Layer即为我们要执行动画的对象，可为它设置合适的长宽大小 3. 依次添加Switch组件，POPAnimation组件，两个Transition组件： Switch：即开关组件，用于控制条件的翻转，这里我们要用它来控制实现点击一下放大图片，再次点击缩小图片的效果。 POPAnimation：Facebook自家出品的动画引擎，覆盖iOS和_Android_web（Android版的名称貌似是叫做Rebound）。通过这个组件可以实现很棒的弹性缩放动画。 Transition1：控制动画效果的关键组件，这里我们通过设置这个组件的起止值，决定图片的缩放比值，旋转角度等参数。 Transition2：控制动画效果的关键组件，这里我们通过设置这个组件的起止值，决定图片的缩放比值，旋转角度等参数。 4. 为各组件添加连线： Transition1的连线关联到了图像组件的Z Rotation属性上，以达到控制图像旋转的目的Transition2的连线关联到了图像组件的Scale属性上，以达到控制图像缩放的目的 5. 设置动画参数： POPAnimation：选中该组件，在右侧的属性面板中修改动画的弹性和摩擦力参数，通过调整这两个值可以达到不同的动画效果，具体效果可以参见POP动画引擎的官方文档facebook/pop - [ ] `Transition1`：选中该组件，在右侧的属性面板中修改动画的旋转角度，这里我们将它设置为360，即旋转一周。 - [ ] `Transition2`：选中该组件，在右侧的属性面板中修改动画的缩放比值，这里我们将它设置为2，即放大一倍。 至此，整个动画的构建就已经完成了，一起来看看动画效果： 三、导出代码并在实际工程中调用动画1. 导出代码点击菜单里的纸鹤按钮，选择Code Export-iOS选项： Origami会生成一个包含动画代码的代码文件： 2. 新建Xcode工程新建一个iOS项目，并简单配置： 3. 引入POP动画引擎建议使用Cocoapods来进行安装，简单快捷方便，当然如果受项目限制必须要手动引入的话，同样参考POP引擎的官方文档facebook/pop Cocoapods的引入代码为： 1pod &quot;pop&quot; 4. 调用动画 将导出的动画代码添加到项目中： Opps!报错了： 不要惊慌，把self.layer.layer替换成我们工程里要操作的控件即可：self.imageView.layer 最后，为imageView添加一个tap手势： 1234567 _tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapHandler)]; //开启imageView的用户交互选项，否则imageView不会响应手势self.imageView.userInteractionEnabled = YES; [self.imageView addGestureRecognizer:_tap]; 以及响应手势的方法：123456789101112131415- (void)tapHandler&#123; if (scaled) &#123;//scaled为自己定义的判断缩放状态的BOOL参数 [self togglePopAnimation:NO]; scaled = !scaled; &#125; else&#123; [self togglePopAnimation:YES]; scaled = !scaled; &#125;&#125; 来看看效果： 大功告成！ 代码及源文件下载：Xcode工程文件 Origami源文件","categories":[],"tags":[{"name":"UI","slug":"UI","permalink":"https://www.akringblog.com/tags/UI/"},{"name":"UX","slug":"UX","permalink":"https://www.akringblog.com/tags/UX/"}]},{"title":"3D Touch在Home Screen上的快捷菜单(一)","slug":"3D Touch在Home Screen上的快捷菜单(一)","date":"2016-03-10T11:00:59.000Z","updated":"2019-01-20T11:06:40.542Z","comments":true,"path":"2016/03/10/3D Touch在Home Screen上的快捷菜单(一)/","link":"","permalink":"https://www.akringblog.com/2016/03/10/3D Touch在Home Screen上的快捷菜单(一)/","excerpt":"随着iOS9和iPhone 6s系列设备的发布，3D Touch为我们提供了一种新的交互方式。其中，通过Home Screen重压App图标来触发快捷菜单(Shortcut)的方式是非常实用的，它为用户提供了常用操作的快捷入口，能有效提升用户的使用体验。","text":"随着iOS9和iPhone 6s系列设备的发布，3D Touch为我们提供了一种新的交互方式。其中，通过Home Screen重压App图标来触发快捷菜单(Shortcut)的方式是非常实用的，它为用户提供了常用操作的快捷入口，能有效提升用户的使用体验。 生成快捷方式的方法有静态生成和动态生成两种，可以根据使用情景选择合适的方式来实现。 生成静态快捷方式 在target的Info标签中，创建一个Array类型的值UIApplicationShortcutItems。 在UIApplicationShortcutItems下创建类型为Dictionary的Item，每个Item都对应一个快捷键选项。 为Item创建三个键值对，分别为： UIApplicationShortcutItemTitle：标题字符串UIApplicationShortcutItemIconType：系统自带的图标类型UIApplicationShortcutItemType：快捷键的标示符字符串 如需自定义图标，则使用这个键值对:UIApplicationShortcutItemIconFile:项目中的图片文件名 创建好的Item示例如下: key 配置快捷键的系统回调用户点击快捷键之后，将在Appdelegate中触发- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler回调，从而使得我们可以针对触发的快捷键进行操作，示例代码如下： 1234- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler&#123; completionHandler([self handleShortCutItem:shortcutItem]);&#125; 根据苹果官方文档的建议，我们需要将快捷键的操作抽取成一个单独的方法，以便我们在didFinishLaunchingWithOptions和performActionForShortcutItem回调中解析快捷键操作，抽取出的解析方法如下： 1234567891011121314151617181920212223242526272829303132333435363738/** * 处理来自Home Screen的快捷键操作 * * @param shortcutItem 快捷键选项 * * @return Bool */- (BOOL)handleShortCutItem:(UIApplicationShortcutItem *)shortcutItem &#123; if (shortcutItem == nil) &#123; return NO; &#125; else&#123; //快捷键1 if ([shortcutItem.type isEqualToString:@\"xxx\"]) &#123; //执行快捷键1的操作 return YES; &#125; //快捷键2 if ([shortcutItem.type isEqualToString:@\"xxx\"]) &#123; //执行快捷键2的操作 return YES; &#125; //快捷键3 if ([shortcutItem.type isEqualToString:@\"xxx\"]) &#123; //执行快捷键3的操作 return YES; &#125; return NO; &#125;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://www.akringblog.com/tags/Swift/"}]},{"title":"AutoLayout动态隐藏控件的方法","slug":"AutoLayout动态隐藏控件的方法","date":"2016-01-20T05:00:29.000Z","updated":"2019-01-20T11:09:22.757Z","comments":true,"path":"2016/01/20/AutoLayout动态隐藏控件的方法/","link":"","permalink":"https://www.akringblog.com/2016/01/20/AutoLayout动态隐藏控件的方法/","excerpt":"使用AutoLayout有一段时间了，配合Xcode6新推出的size class做界面适配和自适应布局非常好用。目前网上有关AutoLayout的教程大都浅尝辄止，或者仅涉及到对设备的横、竖屏的动态布局等比较简单的应用，而对AutoLayout做动态界面相关的内容却非常少，因此结合日常工作中的一些经验，来为大家做一些分享。","text":"使用AutoLayout有一段时间了，配合Xcode6新推出的size class做界面适配和自适应布局非常好用。目前网上有关AutoLayout的教程大都浅尝辄止，或者仅涉及到对设备的横、竖屏的动态布局等比较简单的应用，而对AutoLayout做动态界面相关的内容却非常少，因此结合日常工作中的一些经验，来为大家做一些分享。 我们要做什么相信很多开发者都需要解决这样一系列问题： 我们需要根据用户操作，或服务端返回的数据，而动态显示/隐藏一些控件，以达到灵活布局的效果。 我们需要根据需要调整某一控件的尺寸大小，位置信息，以输出最适宜的界面布局。 面对类似高动态的界面实现时，以往我们的方法是通过代码来计算和判定控件的大小和位置，并结合控件的hidden,frame等属性对其进行设置，在实际使用中往往需要进行比较复杂的计算，比较繁琐。抛开代码党和xib党的争论，下面介绍一种使用AutoLayout实现动态界面的方法。 如示例图所示，我们将要构建一个由三个控件构成的简易应用，通过底部的show和hide按钮，控制第二个组件SecondObject的显示和隐藏，并使得第三个控件根据情况自动布局。 操作步骤一、新建一个iOS项目，在storyboard中拖入三个UILabel控件，并为其设置合适的AutoLayout约束： 第一步 二、 为需要操作的约束设置属性并关联到代码 第二步 这里的两个约束分别是： SecondObjectTopSpace: SecondObject顶部到FirstObject的距离 secondObjectHeight: SecondObject的高度 三、 编写show和hide方法，为约束赋值，直接控制SecondObject的高度和距离’FirstObject’的顶部距离，从而达到完全隐藏/显示SecondObject的目的。 123456- (IBAction)show:(id)sender&#123; self.secondObjectHeight.constant = 107; self.SecondObjectTopSpace.constant = 60;&#125; 123456- (IBAction)hide:(id)sender&#123; self.secondObjectHeight.constant = 0; self.SecondObjectTopSpace.constant = 0;&#125; 附录示例代码下载： AutoLayoutTest","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"QLPreviewController中文乱码的解决方法","slug":"QLPreviewController中文乱码的解决方法","date":"2015-12-28T08:20:31.000Z","updated":"2019-01-20T11:21:58.841Z","comments":true,"path":"2015/12/28/QLPreviewController中文乱码的解决方法/","link":"","permalink":"https://www.akringblog.com/2015/12/28/QLPreviewController中文乱码的解决方法/","excerpt":"在使用QLPreviewController展示TXT等文档时，Windows下生成的UTF-8格式的文件会出现中文（以及其他特殊字符）乱码的问题，一开始以为是因为文档需要转码，在尝试多次无果后，在StackOverFlow上找到了答案，原答链接如下：QLPreviewController and UTF8 characters","text":"在使用QLPreviewController展示TXT等文档时，Windows下生成的UTF-8格式的文件会出现中文（以及其他特殊字符）乱码的问题，一开始以为是因为文档需要转码，在尝试多次无果后，在StackOverFlow上找到了答案，原答链接如下：QLPreviewController and UTF8 characters 解决要点在于 QLPreviewController只有在UTF16的编码下才能正确显示中文，因此我们需要在展示文件之前将文件的编码改为UTF16 需针对ANSI编码和Unicode编码分别进行解码 详细代码如下：1234567891011121314151617181920212223242526- (id &lt;QLPreviewItem&gt;)previewController: (QLPreviewController *)controller previewItemAtIndex:(NSInteger)index&#123; NSString *filePath = _previewItem[@\"filePath\"]; NSData *fileData = [NSData dataWithContentsOfFile:filePath]; //判断是UNICODE编码 NSString *isUNICODE = [[NSString alloc] initWithData:fileData encoding:NSUTF8StringEncoding]; //还是ANSI编码 NSString *isANSI = [[NSString alloc] initWithData:fileData encoding:-2147482062]; if (isUNICODE) &#123; NSString *retStr = [[NSString alloc]initWithCString:[isUNICODE UTF8String] encoding:NSUTF8StringEncoding]; NSData *data = [retStr dataUsingEncoding:NSUTF16StringEncoding]; [data writeToFile:filePath atomically:YES]; &#125; else if(isANSI)&#123; NSData *data = [isANSI dataUsingEncoding:NSUTF16StringEncoding]; [data writeToFile:filePath atomically:YES]; &#125; QLPreviewCustomItem *item = [[QLPreviewCustomItem alloc]initWithTitle:_previewItem[@\"fileName\"] url:[NSURL fileURLWithPath:_previewItem[@\"filePath\"]]]; return item;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"QLPreviewController自定义Title的方法","slug":"QLPreviewController自定义Title的方法","date":"2015-12-20T08:20:31.000Z","updated":"2019-01-20T11:22:29.009Z","comments":true,"path":"2015/12/20/QLPreviewController自定义Title的方法/","link":"","permalink":"https://www.akringblog.com/2015/12/20/QLPreviewController自定义Title的方法/","excerpt":"一、创建自定义QLPreviewItem类","text":"一、创建自定义QLPreviewItem类 QLPreviewCustomItem.h 123456789101112#import &lt;Foundation/Foundation.h&gt;#import &lt;QuickLook/QuickLook.h&gt;@interface QLPreviewCustomItem : NSObject&lt;QLPreviewItem&gt;@property (readonly) NSString* previewItemTitle;@property (readonly) NSURL *previewItemURL;- (id) initWithTitle:(NSString*)title url:(NSURL*)url;@end QLPreviewCustomItem.m 1234567891011121314#import &quot;QLPreviewCustomItem.h&quot;@implementation QLPreviewCustomItem- (id) initWithTitle:(NSString*)title url:(NSURL*)url&#123; self = [super init]; if (self != nil) &#123; _previewItemTitle = title; _previewItemURL = url; &#125; return self;&#125;@end 二、QLPreviewController的DataSource123456- (id &lt;QLPreviewItem&gt;)previewController: (QLPreviewController *)controller previewItemAtIndex:(NSInteger)index&#123; QLPreviewCustomItem *item = [[QLPreviewCustomItem alloc]initWithTitle:_previewItem[@&quot;fileName&quot;] url:[NSURL fileURLWithPath:_previewItem[@&quot;filePath&quot;]]]; return item;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"POP框架开发浅析（一）","slug":"POP框架开发浅析（一）","date":"2015-07-28T08:20:31.000Z","updated":"2019-01-20T11:21:18.609Z","comments":true,"path":"2015/07/28/POP框架开发浅析（一）/","link":"","permalink":"https://www.akringblog.com/2015/07/28/POP框架开发浅析（一）/","excerpt":"一直以来都比较纠结于iOS上的动画效果开发，平铺直叙的交互效果在当今扁平化遍地开花的年代显得太过苍白。私以为在扁平化设计中，动效和阴影的合理使用能够极大的提升APP的手感和吸引力，因此，学习iOS下的动画开发就显得非常有必要了。","text":"一直以来都比较纠结于iOS上的动画效果开发，平铺直叙的交互效果在当今扁平化遍地开花的年代显得太过苍白。私以为在扁平化设计中，动效和阴影的合理使用能够极大的提升APP的手感和吸引力，因此，学习iOS下的动画开发就显得非常有必要了。 初识POPPOP是由Facebook开源的一款动画引擎，曾被用于开发Facebook Paper，其特性可被概括为生动流畅，简单易用。通过POP引擎，我们可以为用户创造出逼真而充满物理效应的动效体验。 安装与集成POP可以通过Cocoapods或手动配置的方式集成到项目中，个人建议使用cocoapods的方式，其pod命令为：pod ‘pop’。未使用cocoapod的同学可以前往POP的Github页面下载Zip压缩包后自行配置与集成。 引入头文件在项目中使用POP仅需引入POP.h头文件即可1#import &lt;pop/POP.h&gt; 动画类型POP默认提供两种动画类型——Spring和Decay，而在此基础上每种类型中又包含了多种动画模式。 Spring Animation(跳跃动画)Spring单词的其中一个含义是弹簧，由此可见此类动画的主要特征就是像弹簧一般可以来回弹动，利用Spring Animation，我们可以创造出富有动感且符合物理规律的动画效果。Spring Animation包含了以下5个主要参数； Bounciness(反弹) 反弹主要影响动画所作用的参数的变化幅度，例如用作缩放动画时，可调节缩放的范围比例。 Speed(速度) 速度主要影响动画作用的时间，速度越慢，则动画从开始到结束所需的时间越长。 Tension(拉力) 拉力主要影响动画弹动的力度及速度，拉力越大则动画执行起来越干净利落，拉力越小则动画执行起来越和缓平滑，具体效果需自行调试后才能有直观的感受。 Friction(摩擦力) 摩擦力参数启用后，动画会不断重复，并且幅度逐渐削弱，直到停止，其效果类似于从桌上推落一只皮球，落地后不断弹起——落下，直至最终静止于地面的过程。摩擦力越大，则动画幅度削弱的越快，从开始到停止的时间也就越短。 Mass(质量) 质量会细微地影响动画的回弹力度和速度，在开启摩擦力参数时效果最为明显。 各参数之间常会互相作用，建议大家都通过控制变量法，在demo上实际观察各项参数对动画效果的影响。 Decay Animation(衰减动画)Decay Animation可以实现衰减的动画效果，其效果类似于汽车刹车，等同于物理概念中的匀变速运动。Decay Animation有一个非常重要的参数——velocity(速率)，其作用等同于物理匀变速运动公式中的加速度a。例如：要创建一个物体移动的动画，那么我们可以为其X方向值设定初始值fromValue，然后设定速率velocity，则动画会从初始值以velocity的速率变化。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"iOS检测手机蜂窝网络制式","slug":"iOS检测手机蜂窝网络制式","date":"2015-05-11T04:30:21.000Z","updated":"2019-01-20T11:17:05.832Z","comments":true,"path":"2015/05/11/iOS检测手机蜂窝网络制式/","link":"","permalink":"https://www.akringblog.com/2015/05/11/iOS检测手机蜂窝网络制式/","excerpt":"","text":"Reachability只能检测当前联网的方式，当Wifi开启的时候就无法获得当前蜂窝网络的连接制式，此方法目前仅使用于运营商项目，仅做记录和交流。 导入CoreTelephony.framework框架 在文件中import CoreTelephony 代码如下： 1234567891011@IBAction func checkNetWork(sender: AnyObject)&#123; let networkInfo = CTTelephonyNetworkInfo() var radioAccessStr = networkInfo.currentRadioAccessTechnology if (radioAccessStr?.characters.count&gt;23) &#123; let index = radioAccessStr?.startIndex.advancedBy(23) radioAccessStr = radioAccessStr!.substringFromIndex(index!) &#125; print(radioAccessStr!) &#125; 输出值为: LTE:4G网络 HSDPA:3G网络 GSM:2G网络（无设备未具体验证）","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://www.akringblog.com/tags/Swift/"}]},{"title":"iOS企业版IPA发布与更新","slug":"iOS企业版IPA发布与更新","date":"2015-03-08T03:30:21.000Z","updated":"2019-01-20T11:16:31.373Z","comments":true,"path":"2015/03/08/iOS企业版IPA发布与更新/","link":"","permalink":"https://www.akringblog.com/2015/03/08/iOS企业版IPA发布与更新/","excerpt":"","text":"##发布 ####打包使用最新的Xcode打包IPA即可，导出时选择企业证书导出，不再赘述。 ####生成Plist文件Xcode6之后使用企业证书打包仅生成IPA文件，不再自动生成Plist文件，因此需要手工生成Plist，Plist文件主要用于后续的更新操作，其范例代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;ipa下载地址http://xxx.xxx.xxx/xxx.ipa&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;@2x应用图标地址，http://xxx.xxx.xxx/Icon@2x.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;应用图标地址，http://xxx.xxx.xxx/Icon.png&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;应用的Bundle ID，com.xxx.xxx&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;应用版本,1.0&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;应用名称，xxx&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; ##更新因为企业版发布避开了AppStore的审核机制，所以可以随意的在应用内加上检测更新的按钮而不用担心审核被拒，通过比对Plist文件中bundle-version与本地CFBundleShortVersionString的值，即可做出更新判断，引导用户进行更新，代码如下：1234567891011121314151617181920212223242526272829303132333435/** * 检查系统更新 * * @param sender 检查更新按钮 */- (IBAction)checkUpdate:(id)sender&#123; //VersionPlistPath是你的Plist文件的位置，如http://xxx.xxx.xxx/xxx.plist NSDictionary* dict = [NSDictionary dictionaryWithContentsOfURL:[NSURL URLWithString:VersionPlistPath]]; if (dict) &#123; NSArray* list = [dict objectForKey:@\"items\"]; NSDictionary* dict2 = [list objectAtIndex:0]; NSDictionary* dict3 = [dict2 objectForKey:@\"metadata\"]; NSString* newVersion = [dict3 objectForKey:@\"bundle-version\"]; NSDictionary *infoDict = [[NSBundle mainBundle] infoDictionary]; NSString *myVersion = [infoDict objectForKey:@\"CFBundleShortVersionString\"]; if (![newVersion isEqualToString:myVersion]) &#123; UIAlertView* alert = [[UIAlertView alloc] initWithTitle:@\"提示\" message:@\"有新版本\" delegate:self cancelButtonTitle:@\"马上去更新\" otherButtonTitles:@\"暂不更新\", nil]; [alert show]; &#125; else&#123; UIAlertView * aler = [[UIAlertView alloc] initWithTitle:@\"提示\" message:@\"您已经是最新版\" delegate:self cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil]; [aler show]; &#125; &#125; else&#123; UIAlertView* alert = [[UIAlertView alloc] initWithTitle:@\"提示\" message:@\"请稍后再试\" delegate:self cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil]; [alert show]; &#125;&#125; 弹出的UIAlertView的代理方法：123456789101112#pragma mark - UIAlertView Delegate- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; if (buttonIndex ==0) &#123; //VersionDownloadPath是你的IPA文件的位置，如http://xxx.xxx.xxx/xxx.ipa [[UIApplication sharedApplication] openURL:[NSURL URLWithString:VersionDownloadPath]]; &#125; else if(buttonIndex ==1)&#123; NSLog(@\"不更新\"); &#125;&#125; iOS9中安装企业证书的信任机制有所改变，首次安装企业版APP时要到”设置”—“通用”—“描述文件”中找到对应的企业证书，然后手动选择信任选项，才能顺利安装企业版App","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"Flask文档读薄（二）","slug":"Flask文档读薄（二）","date":"2015-02-15T05:20:21.000Z","updated":"2019-01-20T11:12:16.792Z","comments":true,"path":"2015/02/15/Flask文档读薄（二）/","link":"","permalink":"https://www.akringblog.com/2015/02/15/Flask文档读薄（二）/","excerpt":"主要摘引自Flask文档的《快速入门》章节 HTTP方法默认情况下，路由只响应GET请求，通过给route()装饰器提供一个 methods 参数，即可让路由响应其他方法:","text":"主要摘引自Flask文档的《快速入门》章节 HTTP方法默认情况下，路由只响应GET请求，通过给route()装饰器提供一个 methods 参数，即可让路由响应其他方法: 1234567# 同时响应GET和POST方法@app.route('/login', methods=['GET', 'POST'])def login(): if request.method == 'POST': # 处理用户提交的登录信息表单 else: # 返回用户登录信息 静态文件在包中或模块旁边创建一个名为static的文件夹，即可在应用中使用 /static 访问其中的静态资源，为静态文件生成URL时，使用特殊的&#39;static&#39;端点名: 1url_for('static',filename=\"style.css\") 请求对象使用前需先导入 1from flask import request 当前的请求方式通过method属性访问，表单数据通过form属性访问: 123456789101112@app.route('/login', methods=['POST', 'GET'])def login(): error = None if request.method == 'POST': # 获取并校验请求方法 if valid_login(request.form['username'], request.form['password']): return log_the_user_in(request.form['username']) else: error = '无效的用户名或密码' else: # 处理GET方法 当form中的键值不存在时，会抛出一个KeyError，需捕获并做相应处理 通过args属性访问URL中包含提交的参数(?key=value): 1searchword = request.args.get('q','')","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.akringblog.com/tags/Python/"}]},{"title":"Flask文档读簿（一）","slug":"Flask文档读簿（一）","date":"2015-02-10T02:00:29.000Z","updated":"2019-01-20T11:11:34.892Z","comments":true,"path":"2015/02/10/Flask文档读簿（一）/","link":"","permalink":"https://www.akringblog.com/2015/02/10/Flask文档读簿（一）/","excerpt":"主要摘引自Flask文档的《快速入门》章节 启用调试模式1app.run(debug=True)","text":"主要摘引自Flask文档的《快速入门》章节 启用调试模式1app.run(debug=True) 多个地址Route的写法1234567@app.route('/')def index(): return 'Index Page'@app.route('/hello')def hello(): return 'Hello World' 附加变量 附加原始变量：&lt;variable_name&gt; 1234@app.route('/user/&lt;username&gt;')def show_user_profile(username): # 展示用户名 return 'User %s' % username 附加转换变量：&lt;converter:variable_name&gt; 1234@app.route('/post/&lt;int:post_id&gt;')def show_post(post_id): # 展示int类型的post_id return 'Post %d' % post_id 网址的唯一性根据URL地址结尾是否带有/，可以分为以下两种情况： 结尾带有/： 123@app.route('/projects/')def projects(): return 'The project page' 在这种情况下，无论输入xxx/projects/还是xxx/projects，都能够正确访问到projects页面，而不用担心404错误 结尾不带/： 123@app.route('/about')def about(): return 'The about page\" 在这种情况下，访问xxx/about没有问题，而访问xxx/about/就会报404 构建URL使用url_for()函数来构造URL： 函数格式：url_for(&#39;函数名&#39;, 参数) 123456@app.route('/profile')def profile(username): pass print url_for('profile', username='John Doe')# 输出/user/John%20Doe 动态构建URL的好处： 比硬编码更具备描述性 允许你一次性修改 URL，而不是到处去找 URL 做修改。 URL 构建会显式地处理特殊字符和 Unicode 数据的转义 如果应用不位于 URL 的根路径，url_for() 会为你妥善地处理这些。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.akringblog.com/tags/Python/"}]},{"title":"Mac下的切图神器——Slicy使用说明","slug":"Mac下的切图神器——Slicy使用说明","date":"2014-12-08T15:30:21.000Z","updated":"2019-01-20T11:18:32.505Z","comments":true,"path":"2014/12/08/Mac下的切图神器——Slicy使用说明/","link":"","permalink":"https://www.akringblog.com/2014/12/08/Mac下的切图神器——Slicy使用说明/","excerpt":"一、前言切图作为美工出图的最后一步，向来都是令人头疼的工作，其工作内容繁琐枯燥，但又必不可少。同时，作为IOS开发者，我们往往需要为程序准备两套图片资源，以应对低清屏和Retina屏的不同需求，随之而来的是切图工作量的成倍增加。今天为大家推荐一款Mac下的切图小工具——Slicy，以上烦恼皆可得到妥善的解决。","text":"一、前言切图作为美工出图的最后一步，向来都是令人头疼的工作，其工作内容繁琐枯燥，但又必不可少。同时，作为IOS开发者，我们往往需要为程序准备两套图片资源，以应对低清屏和Retina屏的不同需求，随之而来的是切图工作量的成倍增加。今天为大家推荐一款Mac下的切图小工具——Slicy，以上烦恼皆可得到妥善的解决。 软件特性 切图方便，简单的拖放即可，傻瓜式操作2. 培养为图片资源合理命名的好习惯 自动生成@2x两套图片，极大方便IOS开发者 二、软件使用1、PSD文件的预处理 这一步可以由UI设计师来处理，不过个人推荐程序员亲自完成这一步骤，因为这里涉及到图片的命名，我们自己来对图片进行命名可以更好的使之符合整个项目的命名规则，方便在项目中对对应图片资源进行调用和管理。 首先用PhotoShop打开美工给你的PSD文件，如下图图中的绿色状态图标即为本次需要切出的素材图片 在右侧分组面板中，选中对应的组“Statues” 对“Statues”组的组名进行重命名，将其重命名为“Statues@2x.png”，全部完成后保存PSD文件即可。 这里要注意别忘了@2x后面的“.png”。同时，这里的命名即为图片素材被切出后的名字，因此建议大家在命名时考虑到项目整体的命名规则和调用的方便来进行命名，避免图片切好之后再来修改名字，浪费时间。 到这里，PSD文件的预处理就完成了，事实上这一步也是整个流程中比较繁琐的一步了，完成了这些，今天的切图工作就已经完成了八成。 2、令人愉悦的切图工作 问：使用Slicy切图总共分几步？ 答：总共分2步 第一步：把PSD拖进去 第二步：把图片拖出来 是的，就是如此简单，打开Slicy的主界面，你可以看到其主界面也是如此的简单。。。 第一步将我们预处理好的PSD文件拖进去，在一段令人愉悦的动画之后，我们会看到这个： 第二步按住Command + A快捷键全选，将图片拖到你需要的地方 可以看到，一套严格命名，大小合规的图片已经被切好导出了，就是这么简单！ 小结Slicy的存在使得原本繁琐的切图工作变得轻松惬意，尤其是当程序猿霸气的对美工妹子说：“看你那么辛苦，今天的图我来切”时，相信大多数美工妹子都会感动的痛哭流涕有木有。。。综上，Slicy使用简单，小巧清爽，实在是居家旅行，杀人灭口勾搭美工的必备神器。","categories":[],"tags":[{"name":"UI","slug":"UI","permalink":"https://www.akringblog.com/tags/UI/"}]},{"title":"修改UISearchBar输入框背景的方法","slug":"修改UISearchBar输入框背景的方法","date":"2014-11-30T00:20:31.000Z","updated":"2019-01-20T11:24:41.379Z","comments":true,"path":"2014/11/30/修改UISearchBar输入框背景的方法/","link":"","permalink":"https://www.akringblog.com/2014/11/30/修改UISearchBar输入框背景的方法/","excerpt":"在上古时期(iOS5)，修改UISearchBar的主要方法为：通过遍历UISearchbar的subView，找到负责输入的(UITextField )view，再修改其背景，达到定制UISearchBar背景的效果，苹果在iOS5后加入了新的接口，用于修改UISearchBar的textField的背景：","text":"在上古时期(iOS5)，修改UISearchBar的主要方法为：通过遍历UISearchbar的subView，找到负责输入的(UITextField )view，再修改其背景，达到定制UISearchBar背景的效果，苹果在iOS5后加入了新的接口，用于修改UISearchBar的textField的背景： setSearchFieldBackgroundImage:forState: 将以上代码放入AppDelegate.m的ViewDidLoad方法中即可： 1UISearchBar.appearance().setSearchFieldBackgroundImage(UIImage(named: &quot;搜索框背景&quot;), forState: UIControlState.Normal)","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"iOS8 Today Extension开发攻略（一）","slug":"iOS8 Today Extension开发攻略（一）","date":"2014-08-08T03:30:21.000Z","updated":"2019-01-20T11:15:02.267Z","comments":true,"path":"2014/08/08/iOS8 Today Extension开发攻略（一）/","link":"","permalink":"https://www.akringblog.com/2014/08/08/iOS8 Today Extension开发攻略（一）/","excerpt":"iOS8为广大开发者带来了不少新的特性，如第三方自定义键盘，通知中心插件等。而位于通知中心中的Today Extension插件是我个人认为最有用的一项，它不仅可以为你的App提供一个快捷功能的入口，还能用于简单的数据展示。这对于增进用户黏着度，扩展应用场景都有很好的帮助。这是我撰写的iOS8 Today Extension开发攻略的第一篇，内容主要集中于如何通过Today Extension，实现快捷跳转到App的指定页面，进而实现快捷操作的目的。","text":"iOS8为广大开发者带来了不少新的特性，如第三方自定义键盘，通知中心插件等。而位于通知中心中的Today Extension插件是我个人认为最有用的一项，它不仅可以为你的App提供一个快捷功能的入口，还能用于简单的数据展示。这对于增进用户黏着度，扩展应用场景都有很好的帮助。这是我撰写的iOS8 Today Extension开发攻略的第一篇，内容主要集中于如何通过Today Extension，实现快捷跳转到App的指定页面，进而实现快捷操作的目的。 ###一、添加Today Extension 新建一个singleView的iOS项目： 新建项目 简单配置Storyboard，为项目添加一个二级页面，通过Modal的形式进行展现： storyboard 为项目添加一个target，类型选择“Application Extension”—“Today Extension”： target 随后，为这个Target设定一个名字： targetName 注意：这里的名字就是插件展示在通知中心中的名字，切勿随意输入，如图： finish 选择Activate这个自动生成的scheme。 接下来，我们就能开始为Today Extension编写逻辑代码和设计UI了。 ###二、设计Today Extension的UI 在创建好Today Extension的target之后，Xcode会自动为我们创建一份Storyboard和一套.h/.m文件： .m 首先我们打开storyboard文件，拖入两个UIButton，并为其配置合适的Autolayout约束： button 因为要考虑到iPhone5/6/6+的屏幕宽度问题，所以使用AutoLayout来配置界面是比较好的选择。当然，小伙伴们想要使用手写代码来适配界面的话也是可以的。 接下来通过以下代码修改widget的左边对齐，否则按钮无法居中显示： 1234- (UIEdgeInsets)widgetMarginInsetsForProposedMarginInsets:(UIEdgeInsets)defaultMarginInsets&#123; return UIEdgeInsetsZero;&#125; 运行一下，即可看到两个按钮都已经居中对齐了： finish ###三、为主应用设置URL Scheme Today Extension和主应用之间的交互主要是通过URL Scheme来完成，首先我们需要为主应用设置一个URL Scheme。打开主应用中的info.plist文件，配置URL Scheme： scheme 如此一来，我们主应用的URL Scheme就已经配置好了，我们可以使用Safari浏览器测试一下，在地址栏中输入TodayWidgetTest://,即可直接调起我们的主应用： safari ###四、编写Today Extension代码 打开TodayViewController.m文件，添加两个Button的点击方法，并关联到Today Extension的StoryBoard。方法的代码如下： screenShot 1234567891011121314151617//弹出Alert窗口- (IBAction)showAlert:(id)sender &#123; NSURL *url = [NSURL URLWithString:@&quot;TodayWidgetTest://showAlert&quot;]; [self.extensionContext openURL:url completionHandler:^(BOOL success) &#123; &#125;];&#125;//弹出第二页- (IBAction)modalSecondView:(id)sender &#123; NSURL *url = [NSURL URLWithString:@&quot;TodayWidgetTest://modalSecondView&quot;]; [self.extensionContext openURL:url completionHandler:^(BOOL success) &#123; &#125;];&#125; 通过判断URL:TodayWidgetTest://modalSecondView的内容，即可让Widget向主应用发送操作的通知 ###五、处理URL 打开项目的AppDelegate.m文件，添加一个系统代理方法： 123456789101112131415161718192021222324252627282930- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; if ([url.absoluteString hasPrefix:@&quot;TodayWidgetTest&quot;])&#123;//处理从今日通知中心过来的请求 UIViewController *root = self.window.rootViewController; if ([url.absoluteString hasSuffix:@&quot;showAlert&quot;])&#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;警告&quot; message:@&quot;TodayWidgetTest&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil]; [alert show]; return YES; &#125; else if ([url.absoluteString hasSuffix:@&quot;modalSecondView&quot;])&#123; SecondViewController *vc = [root.storyboard instantiateViewControllerWithIdentifier:@&quot;secondVC&quot;]; [root presentViewController:vc animated:YES completion:nil]; return YES; &#125; &#125; return YES;&#125; 通过不同的URL后缀，识别并执行对应的操作，这里可以根据需要，执行所需的操作。 至此，Today Extension就可以正常使用了，以下是效果图： gif 附上代码文件：Today Extension","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"纪念OBJC君","slug":"纪念OBJC君","date":"2014-06-05T08:21:38.000Z","updated":"2019-01-20T11:28:41.411Z","comments":true,"path":"2014/06/05/纪念OBJC君/","link":"","permalink":"https://www.akringblog.com/2014/06/05/纪念OBJC君/","excerpt":"一公元二零一四年六月四日，就是苹果召开WWDC后的那天，我独在公司内徘徊，遇见段君，前来问我道，“先生可曾为OBJC写了一点什么没有？”我说“没有”。她就正告我，“先生还是写一点罢；OBJC君生前先生就没为她写过什么文章。”","text":"一公元二零一四年六月四日，就是苹果召开WWDC后的那天，我独在公司内徘徊，遇见段君，前来问我道，“先生可曾为OBJC写了一点什么没有？”我说“没有”。她就正告我，“先生还是写一点罢；OBJC君生前先生就没为她写过什么文章。”这是我知道的，凡我所编辑的博客，大概是因为往往有始无终之故罢，销行一向就甚为寥落，然而在这样的生活艰难中，毅然预定了我两个版面的就有她。我也早觉得有写一点东西的必要了。可是我实在无话可说。我只觉得所住的并非人间。四千多个API的血，洋溢在我的周围，使我艰于呼吸视听，那里还能有什么言语？ 二真的码农，敢于直面惨淡的代码，敢于正视淋漓的BUG。这是怎样的哀痛者和幸福者？然而造化又常常为庸人设计，以时间的流驶，来洗涤注释，仅使留下淡红的异常和微漠的溢出。 三我在二日下午，才知道有苹果召开发布会的事；凌晨便得到噩耗，说苹果居然开枪，死伤至数千API，而OBJC君即在遇害者之列。但我对于这些传说，竟至于颇为怀疑。我向来是不惮以最坏的恶意，来推测苹果的，然而我还不料，也不信竟会下劣凶残到这地步。况且始终微笑着的和蔼的OBJC君，更何至于无端在会场前喋血呢？然而即日证明是事实了，作证的便是她自己的尸骸。还有一具，是OpenGL君的。而且又证明着这不但是杀害，简直是谋杀，因为立刻就有小三取代了她们的地位。 四但是，我还有要说的话。 我没有亲见；听说她，OBJC君，那时是欣然前往的。自然，发布会而已，稍有人心者，谁也不会料到有这样的罗网。但竟在会场前中弹了，从背部入，斜穿心肺，已是致命的创伤，只是没有便死。同去的OpenGL君想扶起她，中了四弹，其一是膝盖，立仆；同去的Alfred君又想去扶起她，也被击，弹从左肩入，穿胸偏右出，也立仆。但她还能坐起来，一个Spotlight在她头部及胸部猛击两棍，于是死掉了。 始终微笑的和蔼的OBJC君确是死掉了，这是真的，有她自己的尸骸为证；沉勇而友爱的Alfred君也死掉了，有她自己的尸骸为证；只有一样沉勇而友爱的OpenGL君还在医院里呻吟。 苟活者在淡红的异常中，会依稀看见微茫的希望；真的码农，将更奋然而前行。 呜呼，我说不出话，但以此记念OBJC君！ 六月四日","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.akringblog.com/tags/杂谈/"}]},{"title":"2014上半年总结","slug":"2014上半年总结","date":"2014-06-01T13:10:23.000Z","updated":"2019-01-20T11:07:44.192Z","comments":true,"path":"2014/06/01/2014上半年总结/","link":"","permalink":"https://www.akringblog.com/2014/06/01/2014上半年总结/","excerpt":"新年过半，现将年初至今的工作及生活状况进行小结，以鞭策自己在下半年继续前行。","text":"新年过半，现将年初至今的工作及生活状况进行小结，以鞭策自己在下半年继续前行。 ###一、生活方面 体重比年初下降了接近10KG，很欣慰能有此成绩，当然中途的那次生病『功不可没』。自上高中以来第一次这么瘦过，感觉很好。 终于下定决心按揭购房了，明年底就可以搬进新家，打算在书房弄个落地窗，在35层高楼上看着城市夜景敲代码的感觉应该不错。当然与此同时经济压力也会比之前大很多，不过压力越大动力越大，下半年更要好好努力了。 不知是否是本命年的原因，上半年诸多不顺，中途又有买房之类的事情参合，以至于鲜少有时间和机会与亲友相聚交流，下半年一定要改正，人生在世，亲友不可抛。 * ###二、工作方面 四月初换了工作，原来的公司出了一些状况导致无法继续运营下去了，之前的项目就此夭折，对此感到比较遗憾，希望原来的团队队友们都能在新公司工作顺利。 和老段的合作项目做完了，包括iPhone端的APP和iPad端的后台（因为我不会做前端web开发……）。值得一提的是项目从头至尾都是我一个人扛，包括iPad后台的UI，从中获得了很多的经验和教训，也算是一段很有意思的经历。 游戏开发暂时陷入了瓶颈，因为Sprite Kit的开发资料实在是少之又少，而后续的构思和想法所需要的技术支撑已经远远超过我现在所有的技术能力，所以近段时间需要深入学习Sprite Kit的开发知识，做好技术储备，预计项目会在9-10月复工，争取年内完成。 近段时间还在准备做一个工具类应用，目前正在做界面UI的设计工作，该应用计划于今年内上线。 ###三、学习方面 上半年是我经验槽飞涨的半年，主要技能点加在了以下几个方面： iOS开发技术，到目前为止今年开发了一款APP（iPad后台比较简单所以忽略不计），并预计在下半年完成1-2款，开发技术比起去年有比较大的提高。 UI设计技术，自从有了Sketch 3，妈妈再也不用担心我的界面丑如翔了。当然水平和专业设计师还有很大的差距，设计感和基本功是硬伤，需要花大量时间进一步学习和打磨。 后台开发技术，因为有云端后台的存在，这一块是我上半年投入最少的，下半年视进度和需要继续学习。 * ###四、下半年计划 学习Swift，因为目前objective-c依然是主流，以及Swift才刚刚发布，所以并未投入时间去学习Swift相关的内容，不过鉴于苹果发展Swift以取代objective-c的态度，尽早接受新鲜事物总是好的。 完成应用和APP。 保持健身，减肥如行舟，不进则退。 总的来说，今年是压力和动力并存的一年，上半年过的多姿，期望下半年过的出彩。","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.akringblog.com/tags/杂谈/"}]},{"title":"AVOS Cloud初探","slug":"AVOS Cloud初探","date":"2014-02-21T08:30:52.000Z","updated":"2019-01-20T11:10:46.610Z","comments":true,"path":"2014/02/21/AVOS Cloud初探/","link":"","permalink":"https://www.akringblog.com/2014/02/21/AVOS Cloud初探/","excerpt":"受朋友所托，需要快速开发一款原型APP供其餐厅使用，因受限于成本、人工及工期，后台开发成为了一件非常麻烦的事情，在仅有我一人开发的前提下同时兼顾前端和后端并不现实，因此我一直在寻找有没有其他更好的解决方案。","text":"受朋友所托，需要快速开发一款原型APP供其餐厅使用，因受限于成本、人工及工期，后台开发成为了一件非常麻烦的事情，在仅有我一人开发的前提下同时兼顾前端和后端并不现实，因此我一直在寻找有没有其他更好的解决方案。 在经过一段时间的寻找和测试之后，我找到了一款名为AVOS Cloud的BaaS，来完成后台支撑功能，下面将简要介绍一下其功能。（本文仅供自己记录及学习使用，非广告软文） ##安装AVOS的安装非常友好，支持通过CocoaPods来进行安装，仅需在Podfile中加入 1Pod &quot;AVOSCloud&quot; 然后Pod Install即可 ##使用存储功能AVOS的IOS端API写的非常简洁优雅，近似于苹果官方API，使用起来非常舒服，下面以数据存储为例： 12345//保存数据到云端AVObject *finalGameScore = [AVObject objectWithClassName:@&quot;finalGameScore&quot;];[finalGameScore setObject:playerName forKey:@&quot;playerName&quot;];[finalGameScore setObject:[NSString stringWithFormat:@&quot;%d&quot;,score] forKey:@&quot;gameScore&quot;];[finalGameScore saveInBackground]; 这段代码将在AVOS云端创建一个finalGameScore类，并构造出一个AVObject对象，以面向对象的方式将数据存储到AVOS云端，非常简洁方便，同时AVOS还提供了saveInBackground等多个保存方法，可一行代码实现后台保存，断线重连自动保存等功能，极大提高开发效率","categories":[],"tags":[{"name":"评测","slug":"评测","permalink":"https://www.akringblog.com/tags/评测/"}]},{"title":"用CGRect映射解决ScrollView上的TextField的键盘遮挡问题","slug":"用CGRect映射解决ScrollView上的TextField的键盘遮挡问题","date":"2013-09-30T04:22:45.000Z","updated":"2019-01-20T11:27:41.731Z","comments":true,"path":"2013/09/30/用CGRect映射解决ScrollView上的TextField的键盘遮挡问题/","link":"","permalink":"https://www.akringblog.com/2013/09/30/用CGRect映射解决ScrollView上的TextField的键盘遮挡问题/","excerpt":"","text":"用CGRect映射解决ScrollView上的TextField的键盘遮挡问题 1234567CGPoint pt;CGRect rc = [textField bounds];rc = [textField convertRect:rc toView:self.scrollView];pt = rc.origin;pt.x = 0;pt.y -= 60;[self.scrollView setContentOffset:pt animated:YES]; 重点在于：[textField convertRect:rc toView:self.scrollView]; 将原本为（0,0,x,y）的rect映射到ScrollView上，得到一个（0,382,x,y）的rect，进而取得textField在scrollView上的相对位置，从而实现滚动","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"iOS代码中使用十六进制颜色的方法","slug":"IOS代码中使用十六进制颜色的方法","date":"2013-06-18T14:30:21.000Z","updated":"2019-01-20T11:15:51.636Z","comments":true,"path":"2013/06/18/IOS代码中使用十六进制颜色的方法/","link":"","permalink":"https://www.akringblog.com/2013/06/18/IOS代码中使用十六进制颜色的方法/","excerpt":"简介在IOS开发过程中，用代码生成控件时经常需要涉及到为控件设定字体颜色，背景色等，IOS中为我们提供了UIColor类，但是其中包含的颜色仅只有一些基本的红(RedColor)绿(GreenClolr)蓝(BlueColor)等，使用起来无法满足我们的需要，因此我们一般会使用其他的方式来设定颜色","text":"简介在IOS开发过程中，用代码生成控件时经常需要涉及到为控件设定字体颜色，背景色等，IOS中为我们提供了UIColor类，但是其中包含的颜色仅只有一些基本的红(RedColor)绿(GreenClolr)蓝(BlueColor)等，使用起来无法满足我们的需要，因此我们一般会使用其他的方式来设定颜色 使用RGB颜色1234UILabel *label; [label setBackgroundColor:[UIColor colorWithRed:25/255 green:30/255 blue:70/255 alpha:1]]; 以上代码中通过设定RGB来实现自定义颜色，其参数如下： [ ] Red:红色值，格式必须为xx/255，或者对应的小数，如：255/255 和 1具有相同的效果 [ ] green:绿色值，注意事项同上 [ ] blue:蓝色值，注意事项同上 [ ] alpha:透明度，介于0-1之间的小数 使用十六进制颜色代码在IOS代码中通过宏定义的方式，即可直接在程序中使用现成的十六进制代码，宏定义如下： 1#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0] 将以上宏定义加入到实现文件的头部，在程序中需要使用十六进制颜色代码时直接调用即可。以下例子中使用的颜色代码为：#EDEDED，语法格式如下： 123UILabel *label;[label setBackgroundColor:UIColorFromRGB(0xEDEDED)]; 以上代码中通过设定十六进制颜色代码来实现自定义颜色，其参数如下： [ ] UIColorFromRGB:即之前的宏定义 [ ] (0xEDEDED):即将颜色代码#EDEDED的#号替换为“0x”即可 小结通过以上方法，即可直接使用已经调好的十六进制颜色代码，省去了不断使用吸色器获取RGB颜色的过程，简化了代码，进而提高开发效率。 鸣谢以上宏定义来自船哥的一篇博文，使用后发现非常好用，故将使用心得贴出。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"新年前夕，来自苹果的礼物","slug":"新年前夕，来自苹果的礼物","date":"2013-01-30T10:22:45.000Z","updated":"2019-01-20T11:26:52.821Z","comments":true,"path":"2013/01/30/新年前夕，来自苹果的礼物/","link":"","permalink":"https://www.akringblog.com/2013/01/30/新年前夕，来自苹果的礼物/","excerpt":"新年前夕，来自苹果的礼物 在折腾了快2个月，先后因为各种原因被拒3次之后，我的第一个APP终于在APP Store上线了。再过两天就是马年新年了，也算是苹果在我本命年前送来的一份礼物吧，虽然过程充满曲折和艰辛，但总算是迈出了第一步。在此也顺便分享一下从这次曲折的审核汲取的经验和教训。","text":"新年前夕，来自苹果的礼物 在折腾了快2个月，先后因为各种原因被拒3次之后，我的第一个APP终于在APP Store上线了。再过两天就是马年新年了，也算是苹果在我本命年前送来的一份礼物吧，虽然过程充满曲折和艰辛，但总算是迈出了第一步。在此也顺便分享一下从这次曲折的审核汲取的经验和教训。 A、熟悉规则是成功的开始苹果为开发者提供了一份详细的审核文档:2013最新审核规则 建议所有准备提交审核的工程师们都仔细逐条的阅读，不要嫌麻烦，否则将来可能会给你的审核带来很多问题。 例子：之前因为阅读文档不仔细，没有注意到苹果对程序内图标的限制，最终因为我使用了一个类似系统APP的方形圆角图标而被拒，这是第一次应用被拒。 B、良好的后勤保障是成功的基石在应用进入“In review”阶段之后，与APP相关的一切都要尽力维持稳定，包括但不限于数据库，服务器等等，如果使用类似云服务器等设备，需要特别关注在审核期间提供商是否有维护或其他可能导致app与服务器无法连接的活动，尽力避免因一些意外情况导致审核失败。 例子：我的app后两次审核失败均是由于“In review”期间服务器崩溃，导致app无法连接服务器，被苹果审核组判定为存在致命bug，直接被拒。（另：不知苹果是否会进行压力测试，怀疑服务器崩溃与此有关）。 C、细节决定成败在严格遵循APP Store的审核规则之余，还需要注意一些细枝末节的细节问题，否则很可能阴沟里翻船。 [x] 例子1：如果app需要登录以后才能测试和操作，那么切记：一定要提供测试帐号！，不要以为“我有提供注册功能啊！”而忽视这个问题，苹果的老爷们是不会乖乖按照你预想的流程来测试的，所以如果你忘了，那么只能下次再来了. [x] 例子2：当app内涉及到一些你或你公司独有的流程的时候，例如你们有一个自己的积分系统，苹果审核人员可能会因为搞不明白积分从何而来，通过什么样的方法可以获得积分，积分有什么用等等而需要你提供一些说明信息，千万不要以为自己的应用是被拒了，这时候只需要提供一个详细说明，审核流程依然会继续往下走的。最好是在提交审核的时候在附加信息里提前注明，有备无患。 最后说下申诉，申诉的速度比较慢，所以在申诉之前要先考虑好，如果比较有把握就提交申诉，如果确实是自己的问题建议不要抱有侥幸心理理，重新上传程序吧，等待申诉的时间也会耗去大约3-5天，抱有侥幸心理除了拖长审核周期以外没有任何帮助。 以上就是本次审核所获得的经验，与大家共享。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"AppStore","slug":"AppStore","permalink":"https://www.akringblog.com/tags/AppStore/"}]},{"title":"ZXING二维码实现重复扫描","slug":"ZXING二维码实现重复扫描","date":"2013-01-10T04:20:31.000Z","updated":"2019-01-20T11:23:54.581Z","comments":true,"path":"2013/01/10/ZXING二维码实现重复扫描/","link":"","permalink":"https://www.akringblog.com/2013/01/10/ZXING二维码实现重复扫描/","excerpt":"ZXING是一个完全开放源码的开源项目，相比ZBAR的API开放，ZXING可定制性非常强。以下是实现ZXING完成一次扫描识别处理后，不退出扫描界面，继续准备下一次扫描的实现代码。","text":"ZXING是一个完全开放源码的开源项目，相比ZBAR的API开放，ZXING可定制性非常强。以下是实现ZXING完成一次扫描识别处理后，不退出扫描界面，继续准备下一次扫描的实现代码。 ###在ZXingWidgetController.h中添加以下方法： 1- (void)reset; ###在ZXingWidgetController.m中编写以上方法的实现代码： 123456- (void)reset&#123; decoding = YES; [overlayView setPoints:nil]; wasCancelled = NO;&#125; ###在你的ZXING处理返回值的回调函数中添加第5行的代码： 123456- (void)zxingController:(ZXingWidgetController *)controller didScanResult:(NSString *)result&#123; //处理返回值的方法 [controller reset];&#125; 并且切记，以上方法的末尾别调用 1[self dismissModalViewControllerAnimated:NO] IOS7 中dismissModalView方法添加了一个block来执行dismiss后的一些额外操作，读者请自行参阅文档修改 这会使ZXING扫描界面被弹出。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]},{"title":"使用UIImageWriteToSavedPhotosAlbum保存图片到相册","slug":"使用UIImageWriteToSavedPhotosAlbum保存图片到相册","date":"2012-11-10T07:20:31.000Z","updated":"2019-01-20T11:24:15.427Z","comments":true,"path":"2012/11/10/使用UIImageWriteToSavedPhotosAlbum保存图片到相册/","link":"","permalink":"https://www.akringblog.com/2012/11/10/使用UIImageWriteToSavedPhotosAlbum保存图片到相册/","excerpt":"遇到项目中需要将网络获取的图片存到IOS设备的相册中的时候，可以使用UIImageWriteToSavedPhotosAlbum，方法如下：","text":"遇到项目中需要将网络获取的图片存到IOS设备的相册中的时候，可以使用UIImageWriteToSavedPhotosAlbum，方法如下： 12345//将获取到的图片转化为UIImageUIImage *img = [UIImage imageNamed:@&quot;获取到的图片.png&quot;]; //将图片img保存到相册中UIImageWriteToSavedPhotosAlbum(img, self, @selector(image:didFinishSavingWithError:contextInfo:), nil); 上述UIImageWriteToSavedPhotosAlbum中， img：为需要存储的照片(UIImage形式)的名称。 self：为相关delegate的目标 @selector：为存储图片操作进行后的回调方法，用于对操作结果进行输出和后续操作 nil：为传递的参数 以下为回调方法： 123456789101112- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo&#123; if (error != NULL)&#123; //判断存储操作是否成功？ //存储失败，可输出相应的错误信息提示用户 &#125;else&#123; //存储成功，输出成功提示 &#125;&#125; 注意：参照苹果官方开发文档，该回调方法的形式必须是上面的 1- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo _ 形式，否则回调时会引起错误，切记！_","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.akringblog.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.akringblog.com/tags/Objective-C/"}]}]}